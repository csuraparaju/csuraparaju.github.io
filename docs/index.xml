<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Krish&#39;s blog</title>
<link>https://csuraparaju.github.io/</link>
<atom:link href="https://csuraparaju.github.io/index.xml" rel="self" type="application/rss+xml"/>
<description>Krish Suraparaju&#39;s personal website and blog.</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Wed, 08 Oct 2025 04:00:00 GMT</lastBuildDate>
<item>
  <title>Algorithms for Sampling from a probability distribution</title>
  <dc:creator>Krish Suraparaju</dc:creator>
  <link>https://csuraparaju.github.io/posts/sampling/</link>
  <description><![CDATA[ 





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Drawing samples from a probability distribution <img src="https://latex.codecogs.com/png.latex?%5Cpi"> is a problem that arises often in computer science. For example in generative AI, language models sample tokens from learned probability distributions to generate new text. In computer graphics, many graphical engines randomly sample light paths bouncing around to simulate realistic lighting. But what exactly does it mean for a computer or an algorithm to sample from a probability distribution? How can a deterministic machine like a modern computer sample “randomly” from a distribution?</p>
</section>
<section id="hardware-assumptions" class="level2">
<h2 class="anchored" data-anchor-id="hardware-assumptions">Hardware Assumptions</h2>
<p>On most modern computers, one bit represents an atom of data or computation. So, if we want our computer to generate random samples, we would probably need it to be able to generate uniformly random bits. Let’s assume we have a black box machine that does exactly that.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Above assumption is not an unrealistic one since we have <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">hardware random bit generators</a> which generate random bits from physical process that produce entropy.</p>
</div>
</div>
</div>
<p>More formally, let <img src="https://latex.codecogs.com/png.latex?B%20%5Cin%20%5C%7B0,%201%5C%7D"> be a uniform random bit with <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BP%7D%5BB%20=%200%5D%20=%20%5Cmathbb%7BP%7D%5BB%20=%201%5D%20=%20%5Cfrac%7B1%7D%7B2%7D"> and assume that we can sample from <img src="https://latex.codecogs.com/png.latex?B">.</p>
</section>
<section id="the-uniform-distribution" class="level2">
<h2 class="anchored" data-anchor-id="the-uniform-distribution">The Uniform Distribution</h2>
<p>Let’s start the discussion by coming up with algorithms for sampling integers uniformly randomly in a fixed range.</p>
<section id="integer-in-range-0-2n" class="level3">
<h3 class="anchored" data-anchor-id="integer-in-range-0-2n">Integer in range <img src="https://latex.codecogs.com/png.latex?%5B0,%202%5EN%5D"></h3>
<p>First, let’s see if we can generate a uniformly random integer <img src="https://latex.codecogs.com/png.latex?M%20%5Cin%20%5C%7B0,%20%5Ccdots,%202%5EN%20-%201%5C%7D">. That is, we want to come up with an algorithm to produce <img src="https://latex.codecogs.com/png.latex?M"> such that <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BP%7D%5BM%20=%20m%5D%20=%20%5Cfrac%7B1%7D%7B2%5EN%7D"> for all <img src="https://latex.codecogs.com/png.latex?m%20%5Cin%20%5C%7B0,%20%5Ccdots,%202%5EN%20-%201%5C%7D">.</p>
<p>Well, given that we only have a random bit generator, there is really only one thing we can do here. We should generate <img src="https://latex.codecogs.com/png.latex?N"> independent bits using our random bit generator and concatenate them together to get the base 2 representation of the integer we return.</p>
<div class="algorithm">
<p><strong>Algorithm 1</strong></p>
<p><img src="https://latex.codecogs.com/png.latex?M%20%5Cgets%200"></p>
<p>for <img src="https://latex.codecogs.com/png.latex?i%20=%201"> to <img src="https://latex.codecogs.com/png.latex?N"> do</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cquad%20M%20%5Cgets%20M%20+%20B_i%20%5Ccdot%202%5Ei"></p>
<p>return <img src="https://latex.codecogs.com/png.latex?M"></p>
</div>
<p>Let’s check that this gives us the desired result. Let <img src="https://latex.codecogs.com/png.latex?B_1,%20B_2,%20%5Cdots,%20B_N"> be the bits we generated. Now, note that for any integer <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20%5C%7B0,%20%5Ccdots,%202%5EN%20-%201%5C%7D">, there exists a unique binary representation: <img src="https://latex.codecogs.com/png.latex?%0Ak%20=%20%5Csum_%7Bi%20=%201%7D%5E%7BN%7D%20b_i%20%5Ccdot%202%5Ei%0A"> where each <img src="https://latex.codecogs.com/png.latex?b_i%20%5Cin%20%5C%7B0,%201%5C%7D"> is the <img src="https://latex.codecogs.com/png.latex?i">-th bit of <img src="https://latex.codecogs.com/png.latex?k">. The probability that <img src="https://latex.codecogs.com/png.latex?M%20=%20k"> is given as: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5BM%20=%20k%5D%20&amp;=%20%5Cmathbb%7BP%7D%5BB_0%20=%20b_0,%20B_1%20=%20b_1,%20%5Ccdots,%20B_n%20=%20b_n%5D%20%5C%5C%0A&amp;=%20%5Cmathbb%7BP%7D%5BB_0%20=%20b_0%5D%20%5Ccdot%20%5Cmathbb%7BP%7D%5BB_1%20=%20b_1%5D%20%5Ccdots%20%5Cmathbb%7BP%7D%5BB_N%20=%20b_n%5D%20%5Ctag%7BBy%20independence%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B1%7D%7B2%7D%20%5Ccdot%20%5Cfrac%7B1%7D%7B2%7D%20%5Ccdots%20%5Cfrac%7B1%7D%7B2%7D%20%5Ctag%7B$N$%20times%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B1%7D%7B2%5EN%7D%0A%5Cend%7Balign*%7D"> as desired.</p>
</section>
<section id="integer-in-arbitrary-range" class="level3">
<h3 class="anchored" data-anchor-id="integer-in-arbitrary-range">Integer in Arbitrary Range</h3>
<p>Great, now lets move onto a slightly more difficult problem: generating a uniformly random integer in <img src="https://latex.codecogs.com/png.latex?%5C%7B0,%20%5Cdots,%20M%5C%7D">, where <img src="https://latex.codecogs.com/png.latex?M"> is not necessarily a power of <img src="https://latex.codecogs.com/png.latex?2">.</p>
<p>A first idea would be to use the same approach as before and concatenate a string of <img src="https://latex.codecogs.com/png.latex?N"> random bits. This, however, does not work. For example, if <img src="https://latex.codecogs.com/png.latex?N%20=%203"> and <img src="https://latex.codecogs.com/png.latex?M%20=%204"> then our random bit generator produces outcomes in the range <img src="https://latex.codecogs.com/png.latex?%5C%7B0,%20%5Cdots,%202%5E3%20-%201%5C%7D%20=%20%5C%7B0,%201,%202,%203,%204,%205,%206,%207%5C%7D">. Each of these <img src="https://latex.codecogs.com/png.latex?8"> outcomes occurs with probability <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B8%7D">. However, we wanted an integer in the range <img src="https://latex.codecogs.com/png.latex?%5C%7B0,%201,%202,%203,%204%5C%7D">, and the probability of each outcome to be exactly <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B5%7D">.</p>
<p>Another approach would be to generate <img src="https://latex.codecogs.com/png.latex?N"> random bits as before, and then return <img src="https://latex.codecogs.com/png.latex?N%20%5Cmod%20(M%20+%201)">. I leave it as an exercise to figure out why this approach also does not work (Hint: use the same counter example from above).</p>
<p>Notice that the issue in the above two approach is that our algorithm considers values that are outside the given range. To fix this problem, one idea would be to simply ignore an integers that are outside the range. More formally, define the algorithm as</p>
<div class="algorithm">
<p><strong>Algorithm 2</strong></p>
<p><img src="https://latex.codecogs.com/png.latex?P%20%5Cgets%20%5Clceil%20%5Clog_2%20(M%20+%201)%20%5Crceil"></p>
<p>repeat</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cquad"> Generate <img src="https://latex.codecogs.com/png.latex?N%20%5Cin%20%5C%7B0,%20%5Ccdots,%202%5EP%20-%201%5C%7D"> using Algorithm 1</p>
<p>until <img src="https://latex.codecogs.com/png.latex?N%20%5Cleq%20M"></p>
<p>return <img src="https://latex.codecogs.com/png.latex?N"></p>
</div>
<p>This algorithm is called rejection sampling. A subtle difference between this algorithm and the previous algorithm is that its running time is non-deterministic. For example, we know that algorithm 1 terminates after generating <img src="https://latex.codecogs.com/png.latex?N"> random bits. Algorithm 2, however, has no such guarantees. It is technically possible that we get really really really unlucky and always generate <img src="https://latex.codecogs.com/png.latex?N%20%3E%20M"> and so the algorithm would never return a number.</p>
<p>So, let’s compute probability that the algorithm terminates, which only happens when <img src="https://latex.codecogs.com/png.latex?N%20%5Cleq%20M"> <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5BN%20%5Cleq%20M%5D%20&amp;=%20%5Csum_%7Bi%20%5Cleq%20M%7D%20%5Cmathbb%7BP%7D%5BN%20=%20i%5D%20%5Ctag%7BCDF%20of%20$N$%7D%20%5C%5C%0A&amp;=%20%5Csum_%7Bi%20=%200%7D%5EM%20%5Cfrac%7B1%7D%7B2%5EN%7D%20%5Ctag%7BFrom%20Algorithm%201%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B(M%20+%201)%7D%7B2%5EN%7D%0A%5Cend%7Balign*%7D"></p>
<p>Note that if <img src="https://latex.codecogs.com/png.latex?M%20%5Cll%20N"> then the exponential in the denominator dominates, and the probability of terminating is near zero. When <img src="https://latex.codecogs.com/png.latex?M%20%5Cgg%20N"> then the fraction is approximately linear, and so the algorithm terminates with higher probability.</p>
<p>However, in the case that the algorithm does return, then we can be sure that it is correct. We prove this below. Note that for any <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20%5C%7B0,%20%5Ccdots,%20M%5C%7D">, we have <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5BN%20=%20k%5D%20&amp;=%20%5Cmathbb%7BP%7D%5BN%20=%20k%20%7C%20N%20%5Cleq%20M%5D%20%5Ctag%7BSince%20$N%20%5Cleq%20M$%20iff%20$N$%20is%20returned%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B%5Cmathbb%7BP%7D%5BN%20=%20k,%20N%20%5Cleq%20M%5D%7D%7B%5Cmathbb%7BP%7D%5BN%20%5Cleq%20M%5D%7D%20%5Ctag%7BDefinition%20of%20conditional%20prob.%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B%5Cmathbb%7BP%7D%5BN%20=%20k%5D%7D%7B%5Cmathbb%7BP%7D%5BN%20%5Cleq%20M%5D%7D%20%5Ctag%7B$k%20%5Cleq%20M$%20so%20if%20$N%20=%20k$,%20we%20know%20$N%20%5Cleq%20M$%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B1/2%5EN%7D%7B(M+1)/2%5EN%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B1%7D%7BM%20+%201%7D%0A%5Cend%7Balign*%7D"> as desired.</p>
</section>
<section id="real-number-in-range-0-1" class="level3">
<h3 class="anchored" data-anchor-id="real-number-in-range-0-1">Real number in range <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D"></h3>
<p>Now let’s move onto the hardest problem yet: sampling a real number in the range <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">. Note that every real number <img src="https://latex.codecogs.com/png.latex?r%20%5Cin%20%5B0,%201%5D"> can be represented as a binary expansion: <img src="https://latex.codecogs.com/png.latex?%0Ar%20=%20%5Csum_%7Bi=1%7D%5E%7B%5Cinfty%7D%20%5Cfrac%7BB_i%7D%7B2%5Ei%7D%20=%200.B_1B_2B_3%5Cdots%0A"> where each <img src="https://latex.codecogs.com/png.latex?B_i%20%5Cin%20%5C%7B0,%201%5C%7D">. Again, our first instinct should be to ask if generating an infinite string of bits and concatenating them gives us the desired result. In this case, it turns out to be true. However, the proof of this fact is non-trivial and takes quite a lot of work.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Main Claim
</div>
</div>
<div class="callout-body-container callout-body">
<p>If <img src="https://latex.codecogs.com/png.latex?B_1,%20B_2,%20B_3,%20%5Cdots"> are independent uniform random bits, then <img src="https://latex.codecogs.com/png.latex?%0AU%20=%20%5Csum_%7Bi=1%7D%5E%7B%5Cinfty%7D%20%5Cfrac%7BB_i%7D%7B2%5Ei%7D%0A"> is uniformly distributed on <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">.</p>
</div>
</div>
<p>To prove this, we need to show that for any interval <img src="https://latex.codecogs.com/png.latex?%5Ba,%20b)%20%5Csubseteq%20%5B0,%201%5D">, we have <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BP%7D%5BU%20%5Cin%20%5Ba,%20b)%5D%20=%20%5Ctext%7Blength%7D(%5Ba,%20b)%5D)%20=%20b%20-%20a%0A"></p>
<section id="partitioning-0-1-and-characterizing-the-partitions" class="level4">
<h4 class="anchored" data-anchor-id="partitioning-0-1-and-characterizing-the-partitions">Partitioning <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D"> and characterizing the partitions</h4>
<p>The proof uses a clever partitioning argument. We’ll divide <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D"> into dyadic intervals, which are defined to be intervals whose endpoints are fractions with powers of 2 in the denominator.</p>
<p>For any arbitrary <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20%5Cmathbb%7BN%7D">, we can partition <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D"> into <img src="https://latex.codecogs.com/png.latex?2%5Ek"> equal intervals: <img src="https://latex.codecogs.com/png.latex?%0AI_j%20=%20%5Cleft%5B%5Cfrac%7Bj%7D%7B2%5Ek%7D,%20%5Cfrac%7Bj+1%7D%7B2%5Ek%7D%5Cright)%20%5Cquad%20%5Ctext%7Bfor%20%7D%20j%20=%200,%201,%20%5Cdots,%202%5Ek%20-%201%0A"></p>
<p>Each interval has length <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%5Ek%7D">, and together they cover the entire unit interval. The larger <img src="https://latex.codecogs.com/png.latex?k">, the better this approximation gets.</p>
<p>Now, I claim that the first <img src="https://latex.codecogs.com/png.latex?k"> bits <img src="https://latex.codecogs.com/png.latex?(B_1,%20%5Cdots,%20B_k)"> of <img src="https://latex.codecogs.com/png.latex?U"> completely determine which dyadic interval <img src="https://latex.codecogs.com/png.latex?I_j"> contains the value <img src="https://latex.codecogs.com/png.latex?U">. Specifically: <img src="https://latex.codecogs.com/png.latex?%0AU%20%5Cin%20I_j%20=%20%5Cleft%5B%5Cfrac%7Bj%7D%7B2%5Ek%7D,%20%5Cfrac%7Bj+1%7D%7B2%5Ek%7D%5Cright)%20%5Ciff%20%5Csum_%7Bi=1%7D%5E%7Bk%7D%20%5Cfrac%7BB_i%7D%7B2%5E%7Bi%7D%7D%20=%20%5Cfrac%7Bj%7D%7B2%5Ek%7D%0A"></p>
<p>To see why, we can decompose <img src="https://latex.codecogs.com/png.latex?U"> into two parts:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0AU%20=%20%5Cunderbrace%7B%5Csum_%7Bi=1%7D%5E%7Bk%7D%20%5Cfrac%7BB_i%7D%7B2%5Ei%7D%7D_%7B:=U_k%7D%20+%20%5Cunderbrace%7B%5Csum_%7Bi=k+1%7D%5E%7B%5Cinfty%7D%5Cfrac%7BB_i%7D%7B2%5Ei%7D%7D_%7B:=R_k%7D%0A"> where <img src="https://latex.codecogs.com/png.latex?U_k"> represents the first <img src="https://latex.codecogs.com/png.latex?k"> bits and <img src="https://latex.codecogs.com/png.latex?R_k"> represents the remaining bits. Now, note that The first <img src="https://latex.codecogs.com/png.latex?k"> bits can only produce discrete values because there are <img src="https://latex.codecogs.com/png.latex?2%5Ek"> possible bit strings of length <img src="https://latex.codecogs.com/png.latex?k">, and these values are <img src="https://latex.codecogs.com/png.latex?%5Cleft%5C%7B0,%20%5Cfrac%7B1%7D%7B2%5Ek%7D,%20%5Cfrac%7B2%7D%7B2%5Ek%7D,%20%5Cldots,%20%5Cfrac%7B2%5Ek-1%7D%7B2%5Ek%7D%5Cright%5C%7D"> Observe that these are exactly the left endpoints of our dyadic intervals <img src="https://latex.codecogs.com/png.latex?I_j">.</p>
<p>Now, The remaining bits <img src="https://latex.codecogs.com/png.latex?R_k"> can be rewritten by factoring out <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%5Ek%7D">: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0AR_k%20&amp;=%20%5Csum_%7Bi=k+1%7D%5E%7B%5Cinfty%7D%20%5Cfrac%7BB_i%7D%7B2%5Ei%7D%20=%20%5Cfrac%7B1%7D%7B2%5Ek%7D%20%5Csum_%7Bi=1%7D%5E%7B%5Cinfty%7D%20%5Cfrac%7BB_%7Bk+i%7D%7D%7B2%5Ei%7D%0A%5Cend%7Balign*%7D"> Since <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi=1%7D%5E%7B%5Cinfty%7D%20%5Cfrac%7BB_%7Bk+i%7D%7D%7B2%5Ei%7D"> is a binary expansion taking values in <img src="https://latex.codecogs.com/png.latex?%5B0,%201)">, we have <img src="https://latex.codecogs.com/png.latex?0%20%5Cleq%20R_k%20%3C%20%5Cfrac%7B1%7D%7B2%5Ek%7D"> So, we have that <img src="https://latex.codecogs.com/png.latex?R_k"> is strictly less than the width of a dyadic interval.</p>
<p>Therefore, we can now claim that if <img src="https://latex.codecogs.com/png.latex?U_k%20=%20%5Cfrac%7Bj%7D%7B2%5Ek%7D">, then <img src="https://latex.codecogs.com/png.latex?U%20=%20%5Cfrac%7Bj%7D%7B2%5Ek%7D%20+%20R_k"> must satisfy <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7Bj%7D%7B2%5Ek%7D%20%5Cleq%20U%20%3C%20%5Cfrac%7Bj+1%7D%7B2%5Ek%7D"> placing <img src="https://latex.codecogs.com/png.latex?U"> in interval <img src="https://latex.codecogs.com/png.latex?I_j">. Conversely, if <img src="https://latex.codecogs.com/png.latex?U%20%5Cin%20I_j">, the constraint <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7Bj%7D%7B2%5Ek%7D%20%5Cleq%20U%20%3C%20%5Cfrac%7Bj+1%7D%7B2%5Ek%7D"> combined with the fact that <img src="https://latex.codecogs.com/png.latex?U_k"> is a discrete value in this range forces <img src="https://latex.codecogs.com/png.latex?U_k%20=%20%5Cfrac%7Bj%7D%7B2%5Ek%7D">. Therefore, we have shown that</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><img src="https://latex.codecogs.com/png.latex?%0AU%20%5Cin%20I_j%20%5Ciff%20%5Csum_%7Bi%20=%201%7D%5Ek%20%5Cfrac%7BB_i%7D%7B2%5Ei%7D%20=%20%5Cfrac%7Bj%7D%7B2%5Ek%7D%0A"></p>
</div>
</div>
</div>
</section>
<section id="probability-of-landing-in-i_j" class="level4">
<h4 class="anchored" data-anchor-id="probability-of-landing-in-i_j">Probability of landing in <img src="https://latex.codecogs.com/png.latex?I_j"></h4>
<p>Now we can calculate the probability that <img src="https://latex.codecogs.com/png.latex?U"> lands in a specific dyadic interval <img src="https://latex.codecogs.com/png.latex?I_j">:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5BU%20%5Cin%20I_j%5D%20&amp;=%20%5Cmathbb%7BP%7D%5Cleft%5B%5Csum_%7Bi=1%7D%5E%7Bk%7D%20%5Cfrac%7BB_i%7D%7B2%5E%7Bi%7D%7D%20=%20%5Cfrac%7Bj%7D%7B2%5Ek%7D%5Cright%5D%20%5C%5C%0A&amp;=%20%5Cmathbb%7BP%7D%5BB_1%20=%20b_1,%20B_2%20=%20b_2,%20%5Cdots,%20B_k%20=%20b_k%5D%0A%5Cend%7Balign*%7D"></p>
<p>where <img src="https://latex.codecogs.com/png.latex?(b_1,%20%5Cdots,%20b_k)"> is the binary representation of <img src="https://latex.codecogs.com/png.latex?j">.</p>
<p>Since the bits are independent and each has probability <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%7D">:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5BU%20%5Cin%20I_j%5D%20&amp;=%20%5Cprod_%7Bi=1%7D%5E%7Bk%7D%20%5Cmathbb%7BP%7D%5BB_i%20=%20b_i%5D%20%5C%5C%0A&amp;=%20%5Cprod_%7Bi=1%7D%5E%7Bk%7D%20%5Cfrac%7B1%7D%7B2%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B1%7D%7B2%5Ek%7D%0A%5Cend%7Balign*%7D"></p>
<p>Note that this is exactly the length of the interval <img src="https://latex.codecogs.com/png.latex?I_j">! Therefore, we have show that at least for dyadic intervals, <img src="https://latex.codecogs.com/png.latex?U"> is uniformly distributed!</p>
</section>
<section id="extending-to-general-intervals" class="level4">
<h4 class="anchored" data-anchor-id="extending-to-general-intervals">Extending to General Intervals</h4>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Technical Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Extending this to the general interval <img src="https://latex.codecogs.com/png.latex?%5Ba,%20b%5D"> is complicated and requires careful machinery taught usually in a course in real analysis. Therefore, will handwave a lot of the technicalities, but do keep in mind that there is more careful argument to be made here.</p>
</div>
</div>
</div>
<p>For a general interval <img src="https://latex.codecogs.com/png.latex?%5Ba,%20b)%20%5Csubseteq%20%5B0,%201%5D">, we approximate it using dyadic intervals. Let <img src="https://latex.codecogs.com/png.latex?J_k"> be the set of indices where <img src="https://latex.codecogs.com/png.latex?I_j%20%5Csubseteq%20%5Ba,%20b)">. Then:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Ba,%20b)%20%5Capprox%20%5Cbigcup_%7Bj%20%5Cin%20J_k%7D%20I_j%0A"></p>
<p>As <img src="https://latex.codecogs.com/png.latex?k"> increases, the dyadic intervals become finer, and this approximation improves.</p>
<p>Since the dyadic intervals are disjoint:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5Cleft%5BU%20%5Cin%20%5Cbigcup_%7Bj%20%5Cin%20J_k%7D%20I_j%5Cright%5D%20&amp;=%20%5Csum_%7Bj%20%5Cin%20J_k%7D%20%5Cmathbb%7BP%7D%5BU%20%5Cin%20I_j%5D%20%5C%5C%0A&amp;=%20%5Csum_%7Bj%20%5Cin%20J_k%7D%20%5Cfrac%7B1%7D%7B2%5Ek%7D%20%5C%5C%0A&amp;=%20%5Cfrac%7B%7CJ_k%7C%7D%7B2%5Ek%7D%0A%5Cend%7Balign*%7D"></p>
<p>where <img src="https://latex.codecogs.com/png.latex?%7CJ_k%7C"> is the number of dyadic intervals that fit inside <img src="https://latex.codecogs.com/png.latex?%5Ba,%20b)">.</p>
</section>
<section id="taking-the-limit" class="level4">
<h4 class="anchored" data-anchor-id="taking-the-limit">Taking the Limit</h4>
<p>Notice that <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B%7CJ_k%7C%7D%7B2%5Ek%7D"> represents the total length of all dyadic intervals contained in <img src="https://latex.codecogs.com/png.latex?%5Ba,%20b)">:</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7B%7CJ_k%7C%7D%7B2%5Ek%7D%20=%20%5Csum_%7Bj%20%5Cin%20J_k%7D%20%5Ctext%7Blength%7D(I_j)%0A"></p>
<p>As <img src="https://latex.codecogs.com/png.latex?k%20%5Cto%20%5Cinfty">, these intervals cover <img src="https://latex.codecogs.com/png.latex?%5Ba,%20b)"> with increasing precision, so we expect</p>
<p><img src="https://latex.codecogs.com/png.latex?%0A%5Clim_%7Bk%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B%7CJ_k%7C%7D%7B2%5Ek%7D%20=%20b%20-%20a%0A"></p>
<p>Therefore:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5BU%20%5Cin%20%5Ba,%20b)%5D%20&amp;=%20%5Clim_%7Bk%20%5Cto%20%5Cinfty%7D%20%5Cmathbb%7BP%7D%5Cleft%5BU%20%5Cin%20%5Cbigcup_%7Bj%20%5Cin%20J_k%7D%20I_j%5Cright%5D%20%5C%5C%0A&amp;=%20%5Clim_%7Bk%20%5Cto%20%5Cinfty%7D%20%5Cfrac%7B%7CJ_k%7C%7D%7B2%5Ek%7D%20%5C%5C%0A&amp;=%20b%20-%20a%20%5C%5C%0A&amp;=%20%5Ctext%7Blength%7D(%5Ba,%20b))%0A%5Cend%7Balign*%7D"></p>
<p>as desired</p>
</section>
<section id="from-theory-to-practice-finite-bit-algorithms" class="level4">
<h4 class="anchored" data-anchor-id="from-theory-to-practice-finite-bit-algorithms">From Theory to Practice: Finite Bit Algorithms</h4>
<p>The theoretical result above is beautiful, but it has a glaring practical issue: we cannot generate an infinite sequence of bits! In the real world, we need to work with a finite number of bits. Fortunately, our proof gives us a natural way to approximate the uniform distribution using only a finite number of bits.</p>
<p>The key insight is that after generating <img src="https://latex.codecogs.com/png.latex?N"> bits, we’ve already determined which of the <img src="https://latex.codecogs.com/png.latex?2%5EN"> dyadic intervals our value falls into. The remaining (ungenerated) bits would only refine our position within that interval, which has width <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7B1%7D%7B2%5EN%7D">. For large <img src="https://latex.codecogs.com/png.latex?N">, this interval is so small that the difference is negligible</p>
<p>This leads us to the following algorithm:</p>
<div class="algorithm">
<p><strong>Algorithm 3</strong></p>
<p><img src="https://latex.codecogs.com/png.latex?U%20%5Cgets%200"></p>
<p>for <img src="https://latex.codecogs.com/png.latex?i%20=%201"> to <img src="https://latex.codecogs.com/png.latex?N"> do</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cquad"> Generate random bit <img src="https://latex.codecogs.com/png.latex?B_i"></p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cquad"> <img src="https://latex.codecogs.com/png.latex?U%20%5Cgets%20U%20+%20B_i%20%5Ccdot%202%5E%7B-i%7D"></p>
<p>return <img src="https://latex.codecogs.com/png.latex?U"></p>
</div>
<p>This algorithm generates values of the form <img src="https://latex.codecogs.com/png.latex?%5Cfrac%7Bk%7D%7B2%5EN%7D"> where <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20%5C%7B0,%201,%20%5Cldots,%202%5EN%20-%201%5C%7D">. In other words, it produces a <em>discrete</em> uniform distribution over <img src="https://latex.codecogs.com/png.latex?2%5EN"> equally-spaced points in <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">, rather than a truly continuous uniform distribution.</p>
<p>Let <img src="https://latex.codecogs.com/png.latex?U_N"> denote the output of Algorithm 3 and let <img src="https://latex.codecogs.com/png.latex?U_%7B%5Ctext%7Btrue%7D%7D"> denote a truly uniform random variable on <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">. How far off is our approximation? Well the maximum distance between any generated value and its “true” counterpart is at most the granularity of our discretization: <img src="https://latex.codecogs.com/png.latex?%0A%5Cmax_%7Bx%20%5Cin%20%5B0,%201%5D%7D%20%7CU_N%20-%20x%7C%20%5Cleq%20%5Cfrac%7B1%7D%7B2%5EN%7D%0A"> So, if <img src="https://latex.codecogs.com/png.latex?N%20=%2064">, then we have: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cfrac%7B1%7D%7B2%5E%7B64%7D%7D%20&amp;%5Capprox%205.42%20%5Ctimes%2010%5E%7B-20%7D%20%5C%5C%0A%5Cend%7Balign*%7D"></p>
<p>This means our approximation error is about <img src="https://latex.codecogs.com/png.latex?10%5E%7B-20%7D">! For all practical purposes, this is indistinguishable from a true uniform distribution. In fact, 64-bit floating point numbers (the standard in most programming languages) have a precision of about <img src="https://latex.codecogs.com/png.latex?10%5E%7B-16%7D">, which is less precise than our sampling error.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Practical Implementation
</div>
</div>
<div class="callout-body-container callout-body">
<p>In practice, most programming languages use 64-bit floating point numbers for representing real numbers. Algorithm 3 with <img src="https://latex.codecogs.com/png.latex?N%20=%2064"> bits produces values that are uniformly distributed on the set of representable floating point numbers in <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">, which is the best we can do given the finite precision of computer arithmetic.</p>
</div>
</div>
<p>Therefore, Algorithm 3 with <img src="https://latex.codecogs.com/png.latex?N%20=%2064"> bits gives us an excellent practical algorithm for sampling (approximately) uniform real numbers in <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">.</p>
</section>
</section>
</section>
<section id="arbitrary-probability-distribution" class="level2">
<h2 class="anchored" data-anchor-id="arbitrary-probability-distribution">Arbitrary Probability Distribution</h2>
<p>That was a lot of work! If it took so much effort just to sample from the uniform distribution, how can we possibly expect to come up with algorithms for complicated probability distributions? Well, it turns out that with not too much extra work we can sample from any arbitrary distribution <img src="https://latex.codecogs.com/png.latex?%5Cpi">. More formally, lets say <img src="https://latex.codecogs.com/png.latex?%5Cpi"> is a probability distribution on a finite state space <img src="https://latex.codecogs.com/png.latex?%5Cchi%20=%20%5C%7Bx_1,%20%5Ccdots%20x_n%5C%7D">. I want to generate an <img src="https://latex.codecogs.com/png.latex?X%20%5Cin%20%5Cchi"> such that <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BP%7D%5BX%20=%20x%5D%20=%20%5Cpi(x)%0A"> Now that we can sample from the uniform distribution on <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">, let’s use that. We will use another clever partitioning technique, similar to what we did for proving the uniform distribution result.</p>
<p>More specifically, we divide the interval <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D"> into <img src="https://latex.codecogs.com/png.latex?N"> consecutive segments. For each <img src="https://latex.codecogs.com/png.latex?i%20%5Cin%20%5C%7B1,%202,%20%5Cldots,%20N%5C%7D">, define segment <img src="https://latex.codecogs.com/png.latex?i"> as: <img src="https://latex.codecogs.com/png.latex?%0AS_i%20=%20%5Cleft%5B%5Csum_%7Bj=1%7D%5E%7Bi-1%7D%20%5Cpi(x_j),%20%5Csum_%7Bj=1%7D%5E%7Bi%7D%20%5Cpi(x_j)%5Cright)%0A"> where by convention, <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bj=1%7D%5E%7B0%7D%20%5Cpi(x_j)%20=%200">.</p>
<p>Observe that segment <img src="https://latex.codecogs.com/png.latex?S_i"> has length: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7Blength%7D(S_i)%20=%20%5Csum_%7Bj=1%7D%5E%7Bi%7D%20%5Cpi(x_j)%20-%20%5Csum_%7Bj=1%7D%5E%7Bi-1%7D%20%5Cpi(x_j)%20=%20%5Cpi(x_i)%0A"></p>
<p>Moreover, these segments partition <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D"> since they are disjoint and: <img src="https://latex.codecogs.com/png.latex?%0A%5Cbigcup_%7Bi=1%7D%5E%7BN%7D%20S_i%20=%20%5B0,%201)%0A"> which follows from the fact that <img src="https://latex.codecogs.com/png.latex?%5Csum_%7Bi=1%7D%5E%7BN%7D%20%5Cpi(x_i)%20=%201"> (since <img src="https://latex.codecogs.com/png.latex?%5Cpi"> is a probability distribution). When we sample uniformly from <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D">, the probability of landing in segment <img src="https://latex.codecogs.com/png.latex?i"> is exactly <img src="https://latex.codecogs.com/png.latex?%5Cpi(x_i)"> (since the segment has length <img src="https://latex.codecogs.com/png.latex?%5Cpi(x_i))."> So if we return <img src="https://latex.codecogs.com/png.latex?x_i"> whenever we land in segment <img src="https://latex.codecogs.com/png.latex?i">, we get the desired distribution!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Intuition
</div>
</div>
<div class="callout-body-container callout-body">
<p>Think of it like a dartboard: if you throw a dart uniformly at random on <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D">, the probability of hitting a region is proportional to its length. By making segment <img src="https://latex.codecogs.com/png.latex?i"> have length <img src="https://latex.codecogs.com/png.latex?%5Cpi(x_i)">, we ensure the probability of hitting it matches our target probability.</p>
</div>
</div>
<p><em>Example:</em> Suppose <img src="https://latex.codecogs.com/png.latex?%5Cmathcal%7BX%7D%20=%20%5C%7Bx_1,%20x_2,%20x_3,%20x_4,%20x_5%5C%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cpi%20=%20(0.15,%200.25,%200.20,%200.30,%200.10)">. We segment the <img src="https://latex.codecogs.com/png.latex?%5B0,%201%5D"> interval as shown below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://csuraparaju.github.io/posts/sampling/segmented_numberline.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Segmented [0, 1] Interval</figcaption>
</figure>
</div>
<p>Now, we can sample a real number uniformly random, and return the segment that this number belongs to.</p>
<section id="formalizing-the-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="formalizing-the-algorithm">Formalizing the Algorithm</h4>
<p>To implement this efficiently, we use cumulative probabilities. Define: <img src="https://latex.codecogs.com/png.latex?%0AF_i%20=%20%5Csum_%7Bj=1%7D%5E%7Bi%7D%20%5Cpi(x_j)%20%5Cquad%20%5Ctext%7Bfor%20%7D%20i%20=%201,%202,%20%5Cldots,%20N%0A"> with <img src="https://latex.codecogs.com/png.latex?F_0%20=%200">. Note that <img src="https://latex.codecogs.com/png.latex?F_i"> represents the cumulative probability up to and including <img src="https://latex.codecogs.com/png.latex?x_i">, so segment <img src="https://latex.codecogs.com/png.latex?i"> corresponds to the interval <img src="https://latex.codecogs.com/png.latex?%5BF_%7Bi-1%7D,%20F_i)">.</p>
<p>Our algorithm returns <img src="https://latex.codecogs.com/png.latex?x_i"> when <img src="https://latex.codecogs.com/png.latex?U"> falls in the interval <img src="https://latex.codecogs.com/png.latex?%5BF_%7Bi-1%7D,%20F_i)">:</p>
<div class="algorithm">
<p><strong>Algorithm 4</strong></p>
<p><strong>Preprocessing:</strong></p>
<p>Compute cumulative probabilities: <img src="https://latex.codecogs.com/png.latex?F_0%20%5Cgets%200"></p>
<p>for <img src="https://latex.codecogs.com/png.latex?i%20=%201"> to <img src="https://latex.codecogs.com/png.latex?N"> do</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cquad"> <img src="https://latex.codecogs.com/png.latex?F_i%20%5Cgets%20F_%7Bi-1%7D%20+%20%5Cpi(x_i)"></p>
<p><strong>Sampling:</strong></p>
<p>Generate <img src="https://latex.codecogs.com/png.latex?U%20%5Csim%20%5Ctext%7BUniform%7D%5B0,%201%5D"> using Algorithm 3</p>
<p>for <img src="https://latex.codecogs.com/png.latex?i%20=%201"> to <img src="https://latex.codecogs.com/png.latex?N"> do</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cquad"> if <img src="https://latex.codecogs.com/png.latex?F_%7Bi-1%7D%20%5Cleq%20U%20%3C%20F_i"> then</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cquad%5Cquad"> return <img src="https://latex.codecogs.com/png.latex?x_i"></p>
</div>
<p>Let’s verify that this algorithm produces the correct distribution. For any <img src="https://latex.codecogs.com/png.latex?x_i%20%5Cin%20%5Cmathcal%7BX%7D">:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5Cmathbb%7BP%7D%5B%5Ctext%7Boutput%7D%20=%20x_i%5D%20&amp;=%20%5Cmathbb%7BP%7D%5BF_%7Bi-1%7D%20%5Cleq%20U%20%3C%20F_i%5D%20%5C%5C%0A&amp;=%20F_i%20-%20F_%7Bi-1%7D%20%5Ctag%7B$U$%20is%20uniform%20on%20$%5B0,1%5D$%7D%20%5C%5C%0A&amp;=%20%5Cleft(%5Csum_%7Bj=1%7D%5E%7Bi%7D%20%5Cpi(x_j)%5Cright)%20-%20%5Cleft(%5Csum_%7Bj=1%7D%5E%7Bi-1%7D%20%5Cpi(x_j)%5Cright)%20%5C%5C%0A&amp;=%20%5Cpi(x_i)%0A%5Cend%7Balign*%7D"></p>
<p>The second equality uses the fact that for a uniform random variable <img src="https://latex.codecogs.com/png.latex?U"> on <img src="https://latex.codecogs.com/png.latex?%5B0,1%5D">, we have <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BP%7D%5Ba%20%5Cleq%20U%20%3C%20b%5D%20=%20b%20-%20a">. Therefore, our algorithm produces samples distributed according to <img src="https://latex.codecogs.com/png.latex?%5Cpi">. Problem solved!</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Computational Complexity
</div>
</div>
<div class="callout-body-container callout-body">
<p>The preprocessing step takes <img src="https://latex.codecogs.com/png.latex?O(N)"> time to compute cumulative probabilities. Each sample then requires <img src="https://latex.codecogs.com/png.latex?O(N)"> time in the worst case to find which segment <img src="https://latex.codecogs.com/png.latex?U"> falls into (via linear search). This can be improved to <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20N)"> per sample using binary search, since the cumulative probabilities <img src="https://latex.codecogs.com/png.latex?F_i"> are sorted.</p>
</div>
</div>


</section>
</section>

 ]]></description>
  <category>math</category>
  <category>cs</category>
  <guid>https://csuraparaju.github.io/posts/sampling/</guid>
  <pubDate>Wed, 08 Oct 2025 04:00:00 GMT</pubDate>
</item>
<item>
  <title>Automatic Differentiation using Dual Numbers</title>
  <dc:creator>Krish Suraparaju</dc:creator>
  <link>https://csuraparaju.github.io/posts/dual-numbers/</link>
  <description><![CDATA[ 





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>I recently came across a curious algebraic structure called the Dual Number system, denoted as <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%20(%5Cepsilon)">. The dual numbers are an extension of the real numbers, with a very interesting property: evaluating a differentiable function <img src="https://latex.codecogs.com/png.latex?f"> at a dual number <img src="https://latex.codecogs.com/png.latex?x"> will give us both <img src="https://latex.codecogs.com/png.latex?f(x)"> and <img src="https://latex.codecogs.com/png.latex?f'(x)"> at the same time. This is a powerful idea in numerical analysis and machine learning, as it allows for efficient computation of derivatives.</p>
</section>
<section id="dual-numbers" class="level2">
<h2 class="anchored" data-anchor-id="dual-numbers">Dual Numbers</h2>
<p>Let <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%20%5Cneq%200"> be a new “number” such that <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%5E2%20=%200"> <span class="citation" data-cites="Penn2022">(Penn 2022)</span>. Before we go any further, we must first ask ourselves if such a number can even exist. The answer is of course not if you want to work in complete fields like <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BC%7D">. No matter how small a real (or complex) number is, as long as it is non-zero, its square will also be non-zero. So why do we care about this number then?</p>
<p>One reason is that it can help us model the notion of an “infinitesimal” from calculus, which can be thought of as a non-zero number that is “smaller” than any other number. Using the definition above then, we note that even though <img src="https://latex.codecogs.com/png.latex?%5Cepsilon"> is non-zero, its square is zero, and so the number is somehow “smaller” than any other real (or complex) number. In order to study this more, let’s assume that such a number actually exists and try to see if any laws we know about <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BC%7D"> does (or does not) break down. Then, let’s see how it can be used to compute derivatives of a function.</p>
<p>The structure we want to study is defined as follows <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BR%7D%20(%5Cepsilon)%20=%20%5C%7B%20a%20+%20b%20%5Cepsilon%20%5Cmid%20a,%20b%20%5Cin%20%5Cmathbb%7BR%7D%20%5C%7D%0A"></p>
</section>
<section id="basic-arithmetic" class="level2">
<h2 class="anchored" data-anchor-id="basic-arithmetic">Basic Arithmetic</h2>
<p>First, let’s define how to add, subtract, and multiply. Given a dual number <img src="https://latex.codecogs.com/png.latex?x%20=%20a%20+%20b%20%5Cepsilon"> and <img src="https://latex.codecogs.com/png.latex?y%20=%20c%20+%20d%20%5Cepsilon">, define: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Ax%20+%20y%20&amp;:=%20(a%20+%20c)%20+%20(b%20+%20d)%20%5Cepsilon%20%5C%5C%0Ax%20-%20y%20&amp;:=%20(a%20-%20c)%20+%20(b%20-%20d)%20%5Cepsilon%20%5C%5C%0Ax%20%5Ccdot%20y%20&amp;:=%20(a%20%5Ccdot%20c)%20+%20(a%20%5Ccdot%20d%20+%20d%20%5Ccdot%20c)%20%5Cepsilon%20%5C%5C%0A%5Cend%7Balign*%7D"></p>
<p>Whenever we create new objects and define operations on the objects, we should always check that they are well defined. That means, for each operation above we need to check that if <img src="https://latex.codecogs.com/png.latex?x%20=%20y"> and <img src="https://latex.codecogs.com/png.latex?z"> is any other dual number then <img src="https://latex.codecogs.com/png.latex?x%20+%20z%20=%20y%20+%20z"> and <img src="https://latex.codecogs.com/png.latex?x%20-%20z%20=%20y%20-%20z"> and <img src="https://latex.codecogs.com/png.latex?x%20%5Ccdot%20z%20=%20y%20%5Ccdot%20z">. In this case, checking this is very easy so I won’t do that. We can also divide <img src="https://latex.codecogs.com/png.latex?x%20/%20y">, given that <img src="https://latex.codecogs.com/png.latex?c%20%5Cneq%200">: <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7Bx%7D%7By%7D%20:=%20%5Cfrac%7Ba%7D%7Bc%7D%20+%20%5Cfrac%7Bb%20%5Ccdot%20c%20-%20a%20%5Ccdot%20d%7D%7Bc%5E2%7D%0A"> Hopefully it is not hard to see that distributivity, associativity, and commutativity follow because we are simply using <img src="https://latex.codecogs.com/png.latex?+,%20-,%20%5Ccdot"> from <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D">. This means all the nice properties we learned in high school about algebra on real numbers (ex. FOIL) still hold. So far so good.</p>
<p>However, things get interesting when we starting playing with multiplication and division operator a bit more. Specifically, what happens when we multiply two numbers <img src="https://latex.codecogs.com/png.latex?0%20+%20b%20%5Cepsilon"> and <img src="https://latex.codecogs.com/png.latex?0%20+%20d%20%5Cepsilon"> where <img src="https://latex.codecogs.com/png.latex?b,%20d%20%5Cneq%200">? Clearly these are non-zero numbers. However, note that <img src="https://latex.codecogs.com/png.latex?%0A(0%20+%20b%5Cepsilon)%20+%20(0%20+%20d%5Cepsilon)%20=%20(0%20%5Ccdot%200)%20+%20(0%20%5Ccdot%20d%20+%20b%20%5Ccdot%200)%5Cepsilon%20=%200%0A"> This s strange! Recall that in <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BC%7D"> there are no zero divisors. That is, if <img src="https://latex.codecogs.com/png.latex?a,%20b%20%5Cin%20%5Cmathbb%7BR%7D%20(%5Ctext%7Bor%20%7D%20%5Cmathbb%7BC%7D)">, and <img src="https://latex.codecogs.com/png.latex?a%20%5Ccdot%20b%20=%200"> then either <img src="https://latex.codecogs.com/png.latex?a%20=%200"> or <img src="https://latex.codecogs.com/png.latex?b%20=%200">. We just saw that this need not be the case for dual numbers anymore! Finally, a place where dual number arithmetic breaks down. Nonetheless, it is still remarkable that most of the basic arithmetic operations and laws from <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> still hold, so let’s see what kind of algebra we can do on these numbers.</p>
</section>
<section id="polynomials" class="level2">
<h2 class="anchored" data-anchor-id="polynomials">Polynomials</h2>
<p>Let’s consider a simple polynomial function over the real numbers <img src="https://latex.codecogs.com/png.latex?f(x)%20=%20x%5E2">. We can extend this function to accept dual numbers as input by replacing the real number <img src="https://latex.codecogs.com/png.latex?x%20=%20a"> with the dual number <img src="https://latex.codecogs.com/png.latex?x%20=%20a%20+%20%5Cepsilon">. <img src="https://latex.codecogs.com/png.latex?%0Af((a%20+%20%5Cepsilon))%20=%20(a+%5Cepsilon)%5Ccdot%20(a%20+%20%5Cepsilon)%20=%20a%5E2%20+%20(a%20+%20a)%20%5Cepsilon%20=%20a%5E2%20+%202%20a%20%5Cepsilon%0A"> Notice what just happened. The term <img src="https://latex.codecogs.com/png.latex?2%20a%20%5Cepsilon"> is the derivative of the function <img src="https://latex.codecogs.com/png.latex?f"> evaluated at <img src="https://latex.codecogs.com/png.latex?x%20=%20a">. By just computing the function <img src="https://latex.codecogs.com/png.latex?f"> at the modified dual number, we were able to get the derivative as well in one computation.</p>
<p>Let’s use the Binomial Theorem to see if this generalizes to <img src="https://latex.codecogs.com/png.latex?f(a%20+%20%5Cepsilon)%20=%20(a+%5Cepsilon)%5En"> for an arbitrary <img src="https://latex.codecogs.com/png.latex?n">: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(a%20+%20%5Cepsilon)%20&amp;=%20(a%20+%20%5Cepsilon)%5En%20%5C%5C%0A&amp;=%20%5Csum_%7Bi%20=%200%7D%5En%20%7Bn%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%20i%7D%20%5Cepsilon%5Ei%20%5C%5C%0A&amp;=%20%7Bn%20%5Cchoose%200%7D%20a%5En%20%5Cepsilon%5E0%20+%20%7Bn%20%5Cchoose%201%7D%20a%5E%7Bn-1%7D%20%5Cepsilon%5E1%20+%20%5Csum_%7Bi%20=%202%7D%5En%20%7Bn%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%20i%7D%20%5Cepsilon%5Ei%20%5C%5C%0A&amp;=%20a%5En%20+%20n%20%5Ccdot%20a%5E%7Bn-1%7D%20%5Cepsilon%0A%5Cend%7Balign*%7D"> Where the last step follows because <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%5E2%20=%200"> (by definition) and so all the other terms with <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%5Ei"> for <img src="https://latex.codecogs.com/png.latex?i%20%5Cgeq%202"> cancels out. Notice that this is exactly what we wanted to see: <img src="https://latex.codecogs.com/png.latex?f(a+%5Cepsilon)%20=%20f(a)%20+%20f'(a)%20%5Cepsilon"></p>
<p>Now, lets go even futher and see if this notion generalizes to an arbitrary polynomial <img src="https://latex.codecogs.com/png.latex?f(a%20+%20%5Cepsilon)%20=%20p_n%20(a%20+%20%5Cepsilon)%5En%20+%20p_%7Bn-1%7D%20(a%20+%20%5Cepsilon)%5E%7Bn-1%7D%20+%20%5Ccdots%20+%20p_1%20(a%20+%20%5Cepsilon)%20+%20p_0">: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(a%20+%20%5Cepsilon)%20&amp;=%20p_n%20(a%20+%20%5Cepsilon)%5En%20+%20p_%7Bn-1%7D%20(a%20+%20%5Cepsilon)%5E%7Bn-1%7D%20+%20%5Ccdots%20+%20p_1%20(a%20+%20%5Cepsilon)%20+%20p_0%20%5C%5C%0A&amp;=%20p_n%20%5Csum_%7Bi%20=%200%7D%5En%20%7Bn%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%20i%7D%20%5Cepsilon%5Ei%20+%20p_%7Bn-1%7D%20%5Csum_%7Bi%20=%200%7D%5E%7Bn-1%7D%20%7Bn-1%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%201-%20i%7D%20%5Cepsilon%5Ei%20+p_1%20(a%20+%20%5Cepsilon)%20+%20p_0%20%20%5C%5C%0A&amp;=%20p_n%20(a%5En%20+%20n%20%5E%7Bn-1%7D%20%5Cepsilon)%20+%20p_%7Bn-1%7D%20(a%5E%7Bn-1%7D%20+%20(n-1)%20a%5E%7Bn-2%7D%20%5Cepsilon)%20+%20%5Ccdots%20+%20p_1%20(a%20+%20%5Cepsilon)%20+%20p_0%20%5C%5C%0A&amp;=%20p_n%20a%5En%20+%20p_n%20n%20a%5E%7Bn-1%7D%5Cepsilon%20+%20p_%7Bn-1%7Da%5E%7Bn-1%7D%20+%20p_%7Bn-1%7D%20(n-1)a%5E%7Bn-2%7D%5Cepsilon%20+%20%5Ccdots%20+%20p_1%20a%20+%20p_1%20%5Cepsilon%20+%20p_0%20%5C%5C%0A&amp;=%20(p_n%20a%5En%20+%20p_%7Bn-1%7D%20a%5E%7Bn-1%7D%20+%20%5Ccdots%20+%20p_1%20a%20+%20p_0)%20+(p_n%20n%20a%5E%7Bn-1%7D%20+%20p_%7Bn-1%7D%20(n-1)%20a%5E%7Bn-2%7D%20+%20%5Ccdots%20+%20p_1)%20%5Cepsilon%20%5C%5C%0A&amp;=%20f(a)%20+%20f'(a)%20%5Cepsilon%0A%5Cend%7Balign*%7D"> and indeed it does.</p>
</section>
<section id="other-functions" class="level2">
<h2 class="anchored" data-anchor-id="other-functions">Other functions</h2>
<p>Maybe we can actually make a stronger claim: does this property holds for all infinitely differentiable functions? So, let <img src="https://latex.codecogs.com/png.latex?f"> be such a function evaluated at the dual number <img src="https://latex.codecogs.com/png.latex?a%20+%20c%20%5Cepsilon"> (note that the coefficient for the dual part need not be 1 anymore). Then we can use the taylor series expansion of <img src="https://latex.codecogs.com/png.latex?f"> to write <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(a%20+%20c%5Cepsilon)%20&amp;=%20%5Csum_%7Bn%20=%200%7D%5E%5Cinfty%20%5Cfrac%7Bf%5E%7B(n)%7D%20(a)%7D%7Bn!%7D%20((a%20+%20c%5Cepsilon)%20-%20a)%5En%20%5C%5C%0A&amp;=%20%5Csum_%7Bn%20=%200%7D%5E%5Cinfty%20%5Cfrac%7Bf%5E%7B(n)%7D%20(a)%7D%7Bn!%7D%20(c%5Cepsilon)%5En%20%5C%5C%0A&amp;=%20%5Cfrac%7Bf%5E%7B(0)%7D%20(a)%7D%7B0!%7D%20(c%5Cepsilon)%5E0%20+%20%5Cfrac%7Bf%5E%7B(1)%7D%20(a)%7D%7B1!%7D%20(c%5Cepsilon)%5E1%20+%20%5Csum_%7Bn%20=%202%7D%5E%5Cinfty%20%5Cfrac%7Bf%5E%7B(n)%7D%20(a)%7D%7Bn!%7D%20(c%5Cepsilon)%5En%20%5C%5C%0A&amp;%20f(a)%20+%20f'(a)%20c%20%5Cepsilon%0A%5Cend%7Balign*%7D"></p>
<p>and again, it does!</p>
<p>But what about composition of functions? Let <img src="https://latex.codecogs.com/png.latex?f,%20g"> be functions extended to dual numbers such that <img src="https://latex.codecogs.com/png.latex?f(a%20+%20c%20%5Cepsilon)%20=%20f(a)%20+%20f'(a)%20c%20%5Cepsilon"> and <img src="https://latex.codecogs.com/png.latex?g(a%20+%20c%20%5Cepsilon)%20=%20g(a)%20+%20g'(a)%20c%20%5Cepsilon">. Then, note that: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(g(a+%5Cepsilon))%20&amp;=%20f(g(a)%20+%20g'(a)%5Cepsilon)%20%5C%5C%0A&amp;=%20f(g(a))%20+%20f'(g(a))%20%5Ccdot%20g'(a)%20%5Cepsilon%20%5C%5C%0A%5Cend%7Balign*%7D"> and notice that the dual component <img src="https://latex.codecogs.com/png.latex?f'(g(a))%20%5Ccdot%20g'(a)"> is exactly the chain rule of derivatives! So, now we can imagine all sorts of complicated functions like <img src="https://latex.codecogs.com/png.latex?%0Af(x)%20=%20%5Csin(e%5E%7Bx%5E2%20+%201%7D)%0A"> and by using the dual number representation, we can compute both the function value and its derivative in a single forward pass through the function.</p>
</section>
<section id="closing-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="closing-thoughts">Closing thoughts</h2>
<p>What I find most beautiful about dual numbers is how they transform the problem of differentiation from a difficult limiting process <img src="https://latex.codecogs.com/png.latex?%0Af'(x)%20=%20%5Clim_%7Bh%20%5Cto%200%7D%20%5Cfrac%7Bf(x+h)%20-%20f(x)%7D%7Bh%7D%0A"> into a problem of pure algebraic manipulation. This is incredibly beautiful because limits are (arguably) one of the ugliest tools in mathematics, and turning it into a formulation of abstract algebra is extremely satisfying.</p>
<p>While we gained zero divisors in dual numbers, what we got in return makes up for it: a computational method for computing derivatives that is exact (no truncation error like finite differences) and efficient (requires roughly the same number of operations as computing <img src="https://latex.codecogs.com/png.latex?f"> itself). This is why dual numbers, despite being a somewhat obscure mathematical structure, power automatic differentiation systems used in training neural networks.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-Penn2022" class="csl-entry">
Penn, Michael. 2022. <span>“The Strange Cousin of the Complex Numbers – the Dual Numbers.”</span>
</div>
</div></section></div> ]]></description>
  <category>math</category>
  <guid>https://csuraparaju.github.io/posts/dual-numbers/</guid>
  <pubDate>Tue, 08 Apr 2025 04:00:00 GMT</pubDate>
</item>
<item>
  <title>Sending Messages over Noisy Channels</title>
  <dc:creator>Krish Suraparaju</dc:creator>
  <link>https://csuraparaju.github.io/posts/noisy-channels/</link>
  <description><![CDATA[ 





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>A fundamental problem in electrical engineering is sending messages over noisy channels. For example, all messages sent over the internet have to eventually be transmitted over physical channels (copper wires or fiber optic cables), and these channels can be damaged by the elements (eg. <a href="https://www.business-reporter.co.uk/management/sharks-ate-our-data">sharks</a>)</p>
<p>I recently came across a method to reduce this problem to a purely mathematical one: the sphere packing problem, which aims to find the densest packing of non-overlapping <img src="https://latex.codecogs.com/png.latex?n"> dimensional spheres in a given space.</p>
</section>
<section id="signals-and-code" class="level2">
<h2 class="anchored" data-anchor-id="signals-and-code">Signals and Code</h2>
<p>But first, let’s define the noisy channel problem more formally. Let <img src="https://latex.codecogs.com/png.latex?T%20%3E%200"> be a fixed length of time corresponding to the length of a signal transmission.</p>
<p>A signal is a continuous function <img src="https://latex.codecogs.com/png.latex?s%20:%20%5B0,%20T%5D%20%5Cto%20%5Cmathbb%7BR%7D,"> where <img src="https://latex.codecogs.com/png.latex?s(t)"> is the amplitude of the signal at time <img src="https://latex.codecogs.com/png.latex?t">, and the frequencies do not surpass some fixed limit <img src="https://latex.codecogs.com/png.latex?W">. Think of <img src="https://latex.codecogs.com/png.latex?s(t)"> as the voltage of the signal at time <img src="https://latex.codecogs.com/png.latex?t"> (for copper wires), or the intensity of a light signal at time <img src="https://latex.codecogs.com/png.latex?t"> (for fiber optic cables).</p>
<p>A code is a finite set of signals <img src="https://latex.codecogs.com/png.latex?%5C%7Bs_1,%20s_2,%20%5Cldots,%20s_n%5C%7D."> This can be thought of as a symbolic alphabet for two computers to communicate over a channel. A simple example of a code is <img src="https://latex.codecogs.com/png.latex?%0A%5C%7B%20s_1(t)%20=%201,%5C;%20s_2(t)%20=%20-1%20%5C%7D,%0A"> which can be used to send binary messages over a channel.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Shannon–Nyquist Sampling Theorem</a> states that any signal <img src="https://latex.codecogs.com/png.latex?s(t)"> with frequencies less than <img src="https://latex.codecogs.com/png.latex?W"> can be uniquely represented by a finite set of samples <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%5C%7B%20s(0),%20s%5C!%5Cleft(%5Ctfrac%7B1%7D%7BW%7D%5Cright),%20s%5C!%5Cleft(%5Ctfrac%7B1%7D%7B2W%7D%5Cright),%20%5Cldots,%20s%5C!%5Cleft(%5Ctfrac%7Bn-1%7D%7B2W%7D%5Cright)%20%5Cright%5C%7D,%0A"> where <img src="https://latex.codecogs.com/png.latex?n%20=%202WT">. This means that we can represent any signal <img src="https://latex.codecogs.com/png.latex?s(t)"> as a vector <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D%20%5Cin%20%5Cmathbb%7BR%7D%5En,"> and any code as a finite subset <img src="https://latex.codecogs.com/png.latex?C%20%5Csubseteq%20%5Cmathbb%7BR%7D%5En">, where each element of <img src="https://latex.codecogs.com/png.latex?C"> represents a signal.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="sampling.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="https://csuraparaju.github.io/posts/noisy-channels/sampling.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></a></p>
</figure>
</div>
<p>The continuous signal above <img src="https://latex.codecogs.com/png.latex?S(t)"> represented by the discrete samples <img src="https://latex.codecogs.com/png.latex?S_i">. Therefore, we will represent a signal as a vector in the remaining discussion.</p>
</section>
<section id="the-noisy-channel" class="level2">
<h2 class="anchored" data-anchor-id="the-noisy-channel">The Noisy Channel</h2>
<p>In the real world, the sent signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> is almost never the same as the received signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D">. This is because the channel introduces noise, which we model as a random perturbation in the input.</p>
<p>Formally, we assume that the received signal is <img src="https://latex.codecogs.com/png.latex?%0A%5Cvec%7Br%7D%20=%20%5Cvec%7Bs%7D%20+%20%5Cvec%7Bz%7D,%0A"> where <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bz%7D"> is a random vector with Gaussian entries (each <img src="https://latex.codecogs.com/png.latex?z_i%20%5Csim%20%5Cmathcal%7BN%7D(0,%20%5Csigma%5E2)"> and is i.i.d). If the receiver wants to determine which signal was sent, a natural decoding strategy is nearest-neighbor decoding: <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Cvec%7Bs%7D%7D%20=%20%5Cunderset%7B%5Cvec%7Bs_i%7D%20%5Cin%20C%7D%7B%5Ctext%7Bargmin%7D%7D%20%5C%7C%20%5Cvec%7Br%7D%20-%20%5Cvec%7Bs_i%7D%20%5C%7C_2.%0A"></p>
<p>However, if two signals in the code are too close together, noise may make decoding ambiguous. For example, in the following situation:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="close_signals.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="https://csuraparaju.github.io/posts/noisy-channels/close_signals.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
<p>which signal does <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> correspond to? Both <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_1%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_2%7D"> are equally likely.</p>
<p><br>
</p>
<p>To solve this problem, remember that we assumed <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D%20=%20%5Cvec%7Bs%7D%20+%20%5Cvec%7Bz%7D"> and that each <img src="https://latex.codecogs.com/png.latex?z_i%20%5Csim%20%5Cmathcal%7BN%7D(0,%20%5Csigma%5E2)">. A fundamental property of the Gaussian distribution is that <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BP%7D%5B-3%20%5Csigma%20%5Cleq%20z_i%20%5Cleq%203%20%5Csigma%5D%20%5Capprox%2099.7%5C%25%0A"> So, we can use this to figure out a bound on the distance between <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> with high probability. In the worst-case, each component is such that <img src="https://latex.codecogs.com/png.latex?%7Cz_i%7C%20=%203%20%5Csigma">. Since we have <img src="https://latex.codecogs.com/png.latex?n"> components, this means that <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5C%7C%20%5Cvec%7Br%7D%20-%20%5Cvec%7Bs%7D%20%5C%7C_2%20=%20%20%5C%7C%20%5Cvec%7Bz%7D%5C%7C_2%20&amp;=%20%5Csqrt%7B%5Csum_%7Bi%20=%201%7D%5E%7Bn%7D%20z_i%5E2%7D%20%5C%5C%20&amp;%5Cleq%5Csqrt%7B%5Csum_%7Bi%20=%201%7D%5E%7Bn%7D%20(3%20%5Csigma)%5E2%7D%20%5C%5C%20&amp;%5Cleq%20%5Csqrt%7Bn%20%5Ccdot%209%20%5Csigma%5E2%7D%20%5C%5C%20&amp;%5Cleq%203%20%5Csigma%20%5Csqrt%7Bn%7D%0A%5Cend%7Balign*%7D"> with probability <img src="https://latex.codecogs.com/png.latex?99.7%5C%25">. This means that the worst-case noise can push the received signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> up to a distance of <img src="https://latex.codecogs.com/png.latex?3%20%5Csigma%20%5Csqrt%7Bn%7D"> away from the true signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D">. This creates a sphere of radius <img src="https://latex.codecogs.com/png.latex?3%20%5Csigma%20%5Csqrt%7Bn%7D"> around <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_1%7D">. To make our decoding as unambiguous as possible, we need to ensure that even when noise pushes <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> to the edge of this sphere, it is still closer to <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> than any other signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_2%7D%20%5Cin%20C">. But signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_2%7D"> also has a sphere of radius <img src="https://latex.codecogs.com/png.latex?3%20%5Csigma%20%5Csqrt%7Bn%7D"> around it. Therefore, to guarantee that two spheres don’t overlap, the minimum distance between any two signals must be at least <img src="https://latex.codecogs.com/png.latex?6%20%5Csigma%20%5Csqrt%7Bn%7D"></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="packed_signal.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="https://csuraparaju.github.io/posts/noisy-channels/packed_signal.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
</section>
<section id="dense-sphere-packing" class="level2">
<h2 class="anchored" data-anchor-id="dense-sphere-packing">Dense Sphere packing</h2>
<p>Now, you might ask: why don’t we just pick signals that are as far apart as possible? For example, we could place just two signals at opposite ends of our signal space.</p>
<p>But recall that a signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> represents the amplitude or voltage of a message over time. Physicists have told us the power of a signal is proportional to the square of its amplitude: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BPower%7D%20%5Cpropto%20%5C%7C%5Cvec%7Bs%7D%5C%7C_2%5E2%20=%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20s_i%5E2%0A"></p>
<p>In practice, we cannot transmit signals with arbitrarily large power. There are physical limits on how much voltage we can apply to a copper wire and how much light we can send through a fiber optic cable. If we set a maximum power budget <img src="https://latex.codecogs.com/png.latex?P">, then all our signals must satisfy <img src="https://latex.codecogs.com/png.latex?%0A%5C%7C%5Cvec%7Bs%7D%5C%7C_2%5E2%20%5Cleq%20nP%20%5Cquad%20%5CLongrightarrow%20%5Cquad%20%5C%7C%5Cvec%7Bs%7D%5C%7C_2%20%5Cleq%20%5Csqrt%7BnP%7D%0A"></p>
<p>This means all our signals must lie within a sphere of radius <img src="https://latex.codecogs.com/png.latex?%5Csqrt%7BnP%7D"> in <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5En">, which is a compact region. The more signals we can fit in this region, the more information we can transmit per signal. For example, a code with 2 signals transmits only 1 bit per transmission, but a code with 256 signals transmits 8 bits per transmission.</p>
<p>At the same time, each signal needs a sphere of radius <img src="https://latex.codecogs.com/png.latex?3%5Csigma%5Csqrt%7Bn%7D"> around it to ensure correct decoding with probability <img src="https://latex.codecogs.com/png.latex?99.7%5C%25">. This is exactly the sphere packing problem: what is the maximum number of non-overlapping spheres of radius <img src="https://latex.codecogs.com/png.latex?3%5Csigma%5Csqrt%7Bn%7D"> that we can pack inside a sphere of radius <img src="https://latex.codecogs.com/png.latex?%5Csqrt%7BnP%7D">? Each sphere center represents a signal in our code, and finding the densest packing directly gives us the code that can transmit the most information reliably. Therefore, the problem of designing optimal codes for noisy channels reduces to an entirely abstract problem in math.</p>


</section>

 ]]></description>
  <category>math</category>
  <category>ece</category>
  <guid>https://csuraparaju.github.io/posts/noisy-channels/</guid>
  <pubDate>Wed, 25 Dec 2024 05:00:00 GMT</pubDate>
</item>
<item>
  <title>Metric Spaces, dimension reduction, and Bourgain Embeddings</title>
  <dc:creator>Krish Suraparaju</dc:creator>
  <link>https://csuraparaju.github.io/posts/bourgain-embedding/</link>
  <description><![CDATA[ 





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Metric embeddings and dimension reduction are important tools in computer science and mathematics for solving the curse of dimensionality. In this post, I want to examine the Bourgain embedding, which shows that any finite metric space can be embedded into an Euclidean metric space space with <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20%E2%81%A1n)"> distortion. While Bourgain embeddings are very impractical (the constant factors in the big - O are huge and the “reduced” dimensions is still high), it is an important result that shows us that no matter how “horrible” the initial metric space is, we can be achieve a distortion factor of <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20n)">.</p>
<p><em>Note</em>: I’ve written this post assuming that the reader has at least taken an undergraduate discrete math course. However, I will still define the important objects we will be using today.</p>
<section id="metric-spaces" class="level3">
<h3 class="anchored" data-anchor-id="metric-spaces">Metric Spaces</h3>
<p>A metric space <img src="https://latex.codecogs.com/png.latex?(X,%20d)"> is a set <img src="https://latex.codecogs.com/png.latex?X"> with a distance function <img src="https://latex.codecogs.com/png.latex?d:%20X%20%5Ctimes%20X%20%5Cto%20%5Cmathbb%7BR%7D">. The distance function satisfies the following properties:</p>
<ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20%5Cgeq%200"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y%20%5Cin%20X"></li>
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20=%200"> if and only if <img src="https://latex.codecogs.com/png.latex?x%20=%20y"></li>
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20=%20d(y,%20x)"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y%20%5Cin%20X"></li>
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20%5Cleq%20d(x,%20z)%20+%20d(z,%20y)"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y,%20z%20%5Cin%20X"></li>
</ol>
<p>Some examples of metric spaces:</p>
<ol type="1">
<li>A weighted graph <img src="https://latex.codecogs.com/png.latex?G%20=%20(V,%20E)"> with <img src="https://latex.codecogs.com/png.latex?X%20=%20V"> and <img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20="> length of the shortest path between <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y">.</li>
<li>The DNA space with <img src="https://latex.codecogs.com/png.latex?X%20=%20%5C%7BA,%20C,%20G,%20T%5C%7D%5En"> and <img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20="> number of positions where <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y"> differ.</li>
<li>The Euclidean space <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5En"> with <img src="https://latex.codecogs.com/png.latex?X%20=%20%5Cmathbb%7BR%7D%5En"> and <img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20=%20%5C%7Cx%20-%20y%5C%7C_2%20=%20%5Csqrt%7B(x_1%20-%20y_1)%5E2%20+%20%5Ccdots%20+%20(x_n%20-%20y_n)%5E2%7D">.</li>
</ol>
</section>
<section id="maps-embeddings-and-distortions" class="level3">
<h3 class="anchored" data-anchor-id="maps-embeddings-and-distortions">Maps, Embeddings and Distortions</h3>
<p>A map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20Y"> between two metric spaces <img src="https://latex.codecogs.com/png.latex?(X,%20d_X)"> and <img src="https://latex.codecogs.com/png.latex?(Y,%20d_Y)"> is called an embedding that maps elements of <img src="https://latex.codecogs.com/png.latex?X"> to elements of <img src="https://latex.codecogs.com/png.latex?Y">.</p>
<p>The embedding is said to be distance-preserving (isometric) if <img src="https://latex.codecogs.com/png.latex?d_Y(f(x),%20f(y))%20=%20d_X(x,%20y)"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y%20%5Cin%20X">. However, very rarely do we have distance-preserving embeddings between metric spaces. Instead, we often consider embeddings that are “almost” distance-preserving.</p>
<p>An embedding with distortion of <img src="https://latex.codecogs.com/png.latex?%5Calpha"> of a metric space <img src="https://latex.codecogs.com/png.latex?(X,%20d_X)"> into another metric space <img src="https://latex.codecogs.com/png.latex?(Y,%20d_Y)"> is a map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20Y"> such that there exists constant <img src="https://latex.codecogs.com/png.latex?r%20%3E%200"> for which <img src="https://latex.codecogs.com/png.latex?r%20%5Ccdot%20d_X(x,%20y)%20%5Cleq%20d_Y(f(x),%20f(y))%20%5Cleq%20%5Calpha%20r%20%5Ccdot%20d_X(x,%20y)%20%5Ctext%7B%20for%20all%20%7D%20x,%20y%20%5Cin%20X"> The distortion of an embedding is the smallest <img src="https://latex.codecogs.com/png.latex?%5Calpha"> for which such a map exists.</p>
<p>Because we are working in a finite set for now, we can equivalently define the distortion in terms of the contraction and expansion. Given a map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20Y">, let:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BContraction%7D(f)%20=%20%5Cmax_%7Bx,%20y%20%5Cin%20X%7D%20%5Cfrac%7Bd_Y(f(x),%20f(y))%7D%7Bd_X(x,%20y)%7D"></p>
<p><img src="https://latex.codecogs.com/png.latex?%20%5Ctext%7BExpansion%7D(f)%20=%20%5Cmax_%7Bx,%20y%20%5Cin%20X%7D%20%5Cfrac%7Bd_X(x,%20y)%7D%7Bd_Y(f(x),%20f(y))%7D"></p>
<p>Define the distortion of <img src="https://latex.codecogs.com/png.latex?f"> as <img src="https://latex.codecogs.com/png.latex?%5Calpha%20=%20%5Ctext%7BExpansion%7D(f)%5Ccdot%5Ctext%7BContraction%7D(f)">.</p>
</section>
</section>
<section id="bourgain-embedding" class="level2">
<h2 class="anchored" data-anchor-id="bourgain-embedding">Bourgain Embedding</h2>
<p>Given an arbitrary finite metric space <img src="https://latex.codecogs.com/png.latex?(X,%20d)"> with <img src="https://latex.codecogs.com/png.latex?n"> points, Bourgain’s theorem says that there exists a map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20%5Cmathbb%7BR%7D%5Ek"> such that the distortion of <img src="https://latex.codecogs.com/png.latex?f"> is <img src="https://latex.codecogs.com/png.latex?%5Calpha%20%5Cin%20O(%5Clog%20n)">, and <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20O(%5Clog%5E2%20n)">. The proof of this theorem is beyond the scope of this post, but it is a constructive proof so there is a natural algorithm that arises from the proof which we can implement.</p>
<p>The Bourgain embedding algorithm is as follows <span class="citation" data-cites="Ye2023">(Ye 2023)</span>:</p>
<ol type="1">
<li><p>Let <img src="https://latex.codecogs.com/png.latex?c"> be a sufficiently large constant, and let <img src="https://latex.codecogs.com/png.latex?%5Clog(n)"> denote the base-2 logarithm of <img src="https://latex.codecogs.com/png.latex?n">.</p></li>
<li><p>For each point <img src="https://latex.codecogs.com/png.latex?x%20%5Cin%20X">, define its embedding vector <img src="https://latex.codecogs.com/png.latex?f(x)"> in the following steps:</p>
<ul>
<li>For <img src="https://latex.codecogs.com/png.latex?i%20%5Cin%20%5C%7B1,%202,%20%5Cdots,%20%5Clceil%20%5Clog_2(n)%20%5Crceil%20%5C%7D">:
<ul>
<li>For <img src="https://latex.codecogs.com/png.latex?j%20%5Cin%20%5C%7B1,%202,%20%5Cdots,%20c%20%5Ccdot%20%5Clceil%20%5Clog_2(n)%20%5Crceil%20%5C%7D">:
<ol type="1">
<li>Choose a random subset <img src="https://latex.codecogs.com/png.latex?S_%7Bij%7D%20%5Csubseteq%20X">, where each <img src="https://latex.codecogs.com/png.latex?y%20%5Cin%20X"> is included in <img src="https://latex.codecogs.com/png.latex?S_%7Bij%7D"> with probability <img src="https://latex.codecogs.com/png.latex?2%5E%7B-i%7D">.</li>
<li>Compute <img src="https://latex.codecogs.com/png.latex?d(x,%20S_%7Bij%7D)">, the minimum distance from <img src="https://latex.codecogs.com/png.latex?x"> to any point in <img src="https://latex.codecogs.com/png.latex?S_%7Bij%7D">.</li>
</ol></li>
<li>Construct the embedding vector: <img src="https://latex.codecogs.com/png.latex?f(x)%20=%20%5Clangle%20d(x,%20S_%7B11%7D),%20d(x,%20S_%7B12%7D),%20%5Cdots,%20d(x,%20S_%7B%5Clceil%20%5Clog_2(n)%20%5Crceil%20%5Ccdot%20c%20%5Ccdot%20%5Clceil%20%5Clog_2(n)%20%5Crceil%7D)%5Crangle."></li>
</ul></li>
</ul></li>
</ol>
<p>An intuition for the algorithm is that it creates a “fingerprint” for each point by measuring its distance to random subsets of the space at multiple scales. So, for each point, we answer the question:</p>
<ul>
<li>“How far am I from a randomly chosen half of all points?”</li>
<li>“How far am I from a randomly chosen quarter of all points?”</li>
<li>“How far am I from a randomly chosen eighth of all points?”</li>
<li>…</li>
</ul>
<p>Why does this capture distance information? Imagine two points <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y"> in our original metric space. If they are close, they’ll have similar distances to most random subsets. When we sample a random subset <img src="https://latex.codecogs.com/png.latex?S">, chances are the nearest point in <img src="https://latex.codecogs.com/png.latex?S"> to <img src="https://latex.codecogs.com/png.latex?x"> will also be close to <img src="https://latex.codecogs.com/png.latex?y"> so, the embedded distances will also be similar.</p>
<p>However, if <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y"> are far apart, then at some scale, we’ll sample points that “separate” them. That is, there will be random subsets where <img src="https://latex.codecogs.com/png.latex?x"> is close to some sampled point but <img src="https://latex.codecogs.com/png.latex?y"> is far from all sampled points (or vice versa). This creates a difference in their fingerprints that the algorithm can capture when construction the embedding.</p>
<p>Note that in practice, this algorithm can be really bad because of the big-O constants. For example, if <img src="https://latex.codecogs.com/png.latex?X%20=%20%5Cmathbb%7BR%7D%5E%7B1000%7D">, and we chose <img src="https://latex.codecogs.com/png.latex?c%20=%20100"> (for less distortion), then the reduced dimension <img src="https://latex.codecogs.com/png.latex?k%20=%20100%20%5Ccdot%20%5Clog%5E2%7B1000%7D%20=%20900">. This is an improvement over the <img src="https://latex.codecogs.com/png.latex?1000"> dimensional space, but just barely.</p>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>Let’s implement this in python using numpy so we can vectorize parts of the code.</p>
<div id="3652f975" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> bourgain_embedding(dist_mat, c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>):</span>
<span id="cb1-4">    n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(dist_mat)</span>
<span id="cb1-5"></span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:</span>
<span id="cb1-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> np.zeros((n, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))</span>
<span id="cb1-8"></span>
<span id="cb1-9">    log_n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>(np.ceil(np.log2(n)))</span>
<span id="cb1-10">    k <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> log_n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> log_n</span>
<span id="cb1-11">    max_dist <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>()</span>
<span id="cb1-12"></span>
<span id="cb1-13">    f_x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.zeros((n, k))</span>
<span id="cb1-14"></span>
<span id="cb1-15">    j <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, log_n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb1-17">        p <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">**</span> (<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>i)</span>
<span id="cb1-18">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> _ <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> log_n):</span>
<span id="cb1-19">            subset_mask <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.random.rand(n) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> p</span>
<span id="cb1-20"></span>
<span id="cb1-21">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> np.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">any</span>(subset_mask):</span>
<span id="cb1-22">                f_x[:, j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> max_dist</span>
<span id="cb1-23">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb1-24">                f_x[:, j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat[:, subset_mask].<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(axis<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb1-25">            j <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-26"></span>
<span id="cb1-27">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> f_x</span></code></pre></div></div>
</div>
<p>We can plot the distortion of this algorithm on a randomly generated metric space, as a function of <img src="https://latex.codecogs.com/png.latex?n"> to see the logarithmic curve.</p>
<div id="1e3f76cd" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb2-2"></span>
<span id="cb2-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> distortion(dist_mat, emb):</span>
<span id="cb2-4">    n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat.shape[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb2-5">    max_expand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span></span>
<span id="cb2-6">    max_contract <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span></span>
<span id="cb2-7"></span>
<span id="cb2-8">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb2-9">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> j <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, n):</span>
<span id="cb2-10">            d0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat[i, j]</span>
<span id="cb2-11">            d1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.linalg.norm(emb[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> emb[j], <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">ord</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb2-12"></span>
<span id="cb2-13">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> d0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> d1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb2-14">                max_expand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(max_expand, d1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> d0)</span>
<span id="cb2-15">                max_contract <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(max_contract, d0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> d1)</span>
<span id="cb2-16"></span>
<span id="cb2-17">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> max_expand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> max_contract</span>
<span id="cb2-18"></span>
<span id="cb2-19"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> gen_random_space(n, d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, seed<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>):</span>
<span id="cb2-20">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> seed <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">is</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>:</span>
<span id="cb2-21">        np.random.seed(seed)</span>
<span id="cb2-22">    X <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.random.randn(n, d)</span>
<span id="cb2-23">    diff <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> X[:, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>, :] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> X[<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>, :, :]</span>
<span id="cb2-24">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> np.linalg.norm(diff, axis<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb2-25"></span>
<span id="cb2-26">c_fixed <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span></span>
<span id="cb2-27">ns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">350</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">750</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>]</span>
<span id="cb2-28"></span>
<span id="cb2-29">distortions <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb2-30"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> n <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> ns:</span>
<span id="cb2-31">    dist_mat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gen_random_space(n, d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, seed<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb2-32">    emb <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> bourgain_embedding(dist_mat, c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>c_fixed)</span>
<span id="cb2-33">    distortions.append(distortion(dist_mat, emb))</span>
<span id="cb2-34"></span>
<span id="cb2-35">log_ns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.log(ns)</span>
<span id="cb2-36">log_ns_scaled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> log_ns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> log_ns[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> distortions[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb2-37"></span>
<span id="cb2-38">plt.figure(figsize<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>))</span>
<span id="cb2-39">plt.plot(ns, distortions, marker<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'o'</span>, label<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain distortion"</span>)</span>
<span id="cb2-40">plt.plot(ns, log_ns_scaled, linestyle<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'--'</span>, label<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r"scaled </span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">log n</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb2-41"></span>
<span id="cb2-42">plt.xlabel(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r"</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">n</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb2-43">plt.ylabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Distortion"</span>)</span>
<span id="cb2-44">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain embedding distortion vs log n"</span>)</span>
<span id="cb2-45">plt.grid(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb2-46">plt.legend()</span>
<span id="cb2-47">plt.tight_layout()</span>
<span id="cb2-48">plt.show()</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://csuraparaju.github.io/posts/bourgain-embedding/index_files/figure-html/cell-3-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Note that the variable <img src="https://latex.codecogs.com/png.latex?c"> is a hyper-parameter to this algorithm, and we can observe distortion as a function of <img src="https://latex.codecogs.com/png.latex?c"> as well.</p>
<div id="66952c2b" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">n_fixed <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span></span>
<span id="cb3-2">cs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">400</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">600</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">700</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">800</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">900</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1100</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1200</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1300</span>]</span>
<span id="cb3-3"></span>
<span id="cb3-4">distortions <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb3-5"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> c <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> cs:</span>
<span id="cb3-6">    dist_mat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gen_random_space(n_fixed, d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, seed<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb3-7">    emb <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> bourgain_embedding(dist_mat, c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>c)</span>
<span id="cb3-8">    distortions.append(distortion(dist_mat, emb))</span>
<span id="cb3-9"></span>
<span id="cb3-10"></span>
<span id="cb3-11">plt.figure(figsize<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>))</span>
<span id="cb3-12">plt.plot(cs, distortions, marker<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'o'</span>, label<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain distortion"</span>)</span>
<span id="cb3-13"></span>
<span id="cb3-14">plt.xlabel(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r"</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">c</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb3-15">plt.ylabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Distortion"</span>)</span>
<span id="cb3-16">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain embedding distortion vs c"</span>)</span>
<span id="cb3-17">plt.grid(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb3-18">plt.legend()</span>
<span id="cb3-19">plt.tight_layout()</span>
<span id="cb3-20">plt.show()</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://csuraparaju.github.io/posts/bourgain-embedding/index_files/figure-html/cell-4-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-Ye2023" class="csl-entry">
Ye, Richard. 2023. <span>“Bourgain’s Embedding Theorem, Johnson-Lindenstrauss Lemma, and the Sparsest Cut Problem.”</span>
</div>
</div></section></div> ]]></description>
  <category>math</category>
  <guid>https://csuraparaju.github.io/posts/bourgain-embedding/</guid>
  <pubDate>Fri, 20 Dec 2024 05:00:00 GMT</pubDate>
</item>
</channel>
</rss>
