<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>Krish&#39;s blog</title>
<link>https://csuraparaju.github.io/</link>
<atom:link href="https://csuraparaju.github.io/index.xml" rel="self" type="application/rss+xml"/>
<description>Krish Suraparaju&#39;s personal website and blog.</description>
<generator>quarto-1.8.26</generator>
<lastBuildDate>Tue, 08 Apr 2025 04:00:00 GMT</lastBuildDate>
<item>
  <title>Automatic Differentiation using Dual Numbers</title>
  <dc:creator>Krish Suraparaju</dc:creator>
  <link>https://csuraparaju.github.io/posts/dual-numbers/</link>
  <description><![CDATA[ 





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>I recently came across a curious algebraic structure called the Dual Number system, denoted as <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%20(%5Cepsilon)">. The dual numbers are an extension of the real numbers, with a very interesting property: evaluating a differentiable function <img src="https://latex.codecogs.com/png.latex?f"> at a dual number <img src="https://latex.codecogs.com/png.latex?x"> will give us both <img src="https://latex.codecogs.com/png.latex?f(x)"> and <img src="https://latex.codecogs.com/png.latex?f'(x)"> at the same time. This is a powerful idea in numerical analysis and machine learning, as it allows for efficient computation of derivatives.</p>
</section>
<section id="dual-numbers" class="level2">
<h2 class="anchored" data-anchor-id="dual-numbers">Dual Numbers</h2>
<p>Let <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%20%5Cneq%200"> be a new “number” such that <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%5E2%20=%200"> <span class="citation" data-cites="Penn2022">(Penn 2022)</span>. Before we go any further, we must first ask ourselves if such a number can even exist. The answer is of course not if you want to work in complete fields like <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BC%7D">. No matter how small a real (or complex) number is, as long as it is non-zero, its square will also be non-zero. So why do we care about this number then?</p>
<p>One reason is that it can help us model the notion of an “infinitesimal” from calculus, which can be thought of as a non-zero number that is “smaller” than any other number. Using the definition above then, we note that even though <img src="https://latex.codecogs.com/png.latex?%5Cepsilon"> is non-zero, its square is zero, and so the number is somehow “smaller” than any other real (or complex) number. In order to study this more, let’s assume that such a number actually exists and try to see if any laws we know about <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BC%7D"> does (or does not) break down. Then, let’s see how it can be used to compute derivatives of a function.</p>
<p>The structure we want to study is defined as follows <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BR%7D%20(%5Cepsilon)%20=%20%5C%7B%20a%20+%20b%20%5Cepsilon%20%5Cmid%20a,%20b%20%5Cin%20%5Cmathbb%7BR%7D%20%5C%7D%0A"></p>
<p>Let’s see what we can do with this set.</p>
</section>
<section id="basic-arithmetic" class="level2">
<h2 class="anchored" data-anchor-id="basic-arithmetic">Basic Arithmetic</h2>
<p>First, let’s define how to add, subtract, and multiply. Given a dual number <img src="https://latex.codecogs.com/png.latex?x%20=%20a%20+%20b%20%5Cepsilon"> and <img src="https://latex.codecogs.com/png.latex?y%20=%20c%20+%20d%20%5Cepsilon">, define: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Ax%20+%20y%20&amp;:=%20(a%20+%20c)%20+%20(b%20+%20d)%20%5Cepsilon%20%5C%5C%0Ax%20-%20y%20&amp;:=%20(a%20-%20c)%20+%20(b%20-%20d)%20%5Cepsilon%20%5C%5C%0Ax%20%5Ccdot%20y%20&amp;:=%20(a%20%5Ccdot%20c)%20+%20(a%20%5Ccdot%20d%20+%20d%20%5Ccdot%20c)%20%5Cepsilon%20%5C%5C%0A%5Cend%7Balign*%7D"></p>
<p>Whenever we create new objects and define operations on the objects, we should always check that they are well defined. That means, for each operation above we need to check that if <img src="https://latex.codecogs.com/png.latex?x%20=%20y"> and <img src="https://latex.codecogs.com/png.latex?z"> is any other dual number then <img src="https://latex.codecogs.com/png.latex?x%20+%20z%20=%20y%20+%20z"> and <img src="https://latex.codecogs.com/png.latex?x%20-%20z%20=%20y%20-%20z"> and <img src="https://latex.codecogs.com/png.latex?x%20%5Ccdot%20z%20=%20y%20%5Ccdot%20z">. In this case, checking this is very easy so I won’t do that. We can also divide <img src="https://latex.codecogs.com/png.latex?x%20/%20y">, given that <img src="https://latex.codecogs.com/png.latex?c%20%5Cneq%200">: <img src="https://latex.codecogs.com/png.latex?%0A%5Cfrac%7Bx%7D%7By%7D%20:=%20%5Cfrac%7Ba%7D%7Bc%7D%20+%20%5Cfrac%7Bb%20%5Ccdot%20c%20-%20a%20%5Ccdot%20d%7D%7Bc%5E2%7D%0A"> So far so good. Hopefully it is not hard to see that distributivity, associativity, and commutativity follow because we are simply using <img src="https://latex.codecogs.com/png.latex?+,%20-,%20%5Ccdot"> from <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D">. This means all the nice properties we learned in high school about algebra on real numbers (ex. FOIL) still hold. So far so good.</p>
<p>However, things get interesting when we starting playing with multiplication and division operator a bit more. Specifically, what happens when we multiply two numbers <img src="https://latex.codecogs.com/png.latex?0%20+%20b%20%5Cepsilon"> and <img src="https://latex.codecogs.com/png.latex?0%20+%20d%20%5Cepsilon"> where <img src="https://latex.codecogs.com/png.latex?b,%20d%20%5Cneq%200">. Clearly these are non-zero numbers. However, note that <img src="https://latex.codecogs.com/png.latex?%0A(0%20+%20b%5Cepsilon)%20+%20(0%20+%20d%5Cepsilon)%20=%20(0%20%5Ccdot%200)%20+%20(0%20%5Ccdot%20d%20+%20b%20%5Ccdot%200)%5Cepsilon%20=%200%0A"> This s strange! Recall that in <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BC%7D"> there are no zero divisors. That is, if <img src="https://latex.codecogs.com/png.latex?a,%20b%20%5Cin%20%5Cmathbb%7BR%7D%20(%5Ctext%7Bor%20%7D%20%5Cmathbb%7BC%7D)">, and <img src="https://latex.codecogs.com/png.latex?a%20%5Ccdot%20b%20=%200"> then either <img src="https://latex.codecogs.com/png.latex?a%20=%200"> or <img src="https://latex.codecogs.com/png.latex?b%20=%200">. We just saw that this need not be the case for dual numbers anymore! Finally, a place where dual number arithmetic breaks down. Nonetheless, it is still remarkable that most of the basic arithmetic operations and laws from <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D"> still hold, so let’s see what kind of algebra we can do on these numbers.</p>
</section>
<section id="polynomials" class="level2">
<h2 class="anchored" data-anchor-id="polynomials">Polynomials</h2>
<p>Let’s consider a simple polynomial function over the real numbers <img src="https://latex.codecogs.com/png.latex?f(x)%20=%20x%5E2">. We can extend this function to accept dual numbers as input by replacing the real number <img src="https://latex.codecogs.com/png.latex?x%20=%20a"> with the dual number <img src="https://latex.codecogs.com/png.latex?x%20=%20a%20+%20%5Cepsilon">. <img src="https://latex.codecogs.com/png.latex?%0Af((a%20+%20%5Cepsilon))%20=%20(a+%5Cepsilon)%5Ccdot%20(a%20+%20%5Cepsilon)%20=%20a%5E2%20+%20(a%20+%20a)%20%5Cepsilon%20=%20a%5E2%20+%202%20a%20%5Cepsilon%0A"> Notice what just happened! The term <img src="https://latex.codecogs.com/png.latex?2%20a%20%5Cepsilon"> is the derivative of the function <img src="https://latex.codecogs.com/png.latex?f"> evaluated at <img src="https://latex.codecogs.com/png.latex?x%20=%20a">! By just computing the function <img src="https://latex.codecogs.com/png.latex?f"> at the modified dual number, we were able to get the derivative as well in one computation!</p>
<p>Let’s use the Binomial Theorem to see if this generalizes to <img src="https://latex.codecogs.com/png.latex?f(a%20+%20%5Cepsilon)%20=%20(a+%5Cepsilon)%5En"> for an arbitrary <img src="https://latex.codecogs.com/png.latex?n">: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(a%20+%20%5Cepsilon)%20&amp;=%20(a%20+%20%5Cepsilon)%5En%20%5C%5C%0A&amp;=%20%5Csum_%7Bi%20=%200%7D%5En%20%7Bn%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%20i%7D%20%5Cepsilon%5Ei%20%5C%5C%0A&amp;=%20%7Bn%20%5Cchoose%200%7D%20a%5En%20%5Cepsilon%5E0%20+%20%7Bn%20%5Cchoose%201%7D%20a%5E%7Bn-1%7D%20%5Cepsilon%5E1%20+%20%5Csum_%7Bi%20=%202%7D%5En%20%7Bn%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%20i%7D%20%5Cepsilon%5Ei%20%5C%5C%0A&amp;=%20a%5En%20+%20n%20%5Ccdot%20a%5E%7Bn-1%7D%20%5Cepsilon%0A%5Cend%7Balign*%7D"> Where the last step follows because <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%5E2%20=%200"> (by definition) and so all the other terms with <img src="https://latex.codecogs.com/png.latex?%5Cepsilon%5Ei"> for <img src="https://latex.codecogs.com/png.latex?i%20%5Cgeq%202"> cancels out. Notice that this is exactly what we wanted to see: <img src="https://latex.codecogs.com/png.latex?f(a+%5Cepsilon)%20=%20f(a)%20+%20f'(a)%20%5Cepsilon"></p>
<p>Now, lets go even futher and see if this notion generalizes to an arbitrary polynomial <img src="https://latex.codecogs.com/png.latex?f(a%20+%20%5Cepsilon)%20=%20p_n%20(a%20+%20%5Cepsilon)%5En%20+%20p_%7Bn-1%7D%20(a%20+%20%5Cepsilon)%5E%7Bn-1%7D%20+%20%5Ccdots%20+%20p_1%20(a%20+%20%5Cepsilon)%20+%20p_0">: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(a%20+%20%5Cepsilon)%20&amp;=%20p_n%20(a%20+%20%5Cepsilon)%5En%20+%20p_%7Bn-1%7D%20(a%20+%20%5Cepsilon)%5E%7Bn-1%7D%20+%20%5Ccdots%20+%20p_1%20(a%20+%20%5Cepsilon)%20+%20p_0%20%5C%5C%0A&amp;=%20p_n%20%5Csum_%7Bi%20=%200%7D%5En%20%7Bn%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%20i%7D%20%5Cepsilon%5Ei%20+%20p_%7Bn-1%7D%20%5Csum_%7Bi%20=%200%7D%5E%7Bn-1%7D%20%7Bn-1%20%5Cchoose%20i%7D%20a%5E%7Bn%20-%201-%20i%7D%20%5Cepsilon%5Ei%20+p_1%20(a%20+%20%5Cepsilon)%20+%20p_0%20%20%5C%5C%0A&amp;=%20p_n%20(a%5En%20+%20n%20%5E%7Bn-1%7D%20%5Cepsilon)%20+%20p_%7Bn-1%7D%20(a%5E%7Bn-1%7D%20+%20(n-1)%20a%5E%7Bn-2%7D%20%5Cepsilon)%20+%20%5Ccdots%20+%20p_1%20(a%20+%20%5Cepsilon)%20+%20p_0%20%5C%5C%0A&amp;=%20p_n%20a%5En%20+%20p_n%20n%20a%5E%7Bn-1%7D%5Cepsilon%20+%20p_%7Bn-1%7Da%5E%7Bn-1%7D%20+%20p_%7Bn-1%7D%20(n-1)a%5E%7Bn-2%7D%5Cepsilon%20+%20%5Ccdots%20+%20p_1%20a%20+%20p_1%20%5Cepsilon%20+%20p_0%20%5C%5C%0A&amp;=%20(p_n%20a%5En%20+%20p_%7Bn-1%7D%20a%5E%7Bn-1%7D%20+%20%5Ccdots%20+%20p_1%20a%20+%20p_0)%20+(p_n%20n%20a%5E%7Bn-1%7D%20+%20p_%7Bn-1%7D%20(n-1)%20a%5E%7Bn-2%7D%20+%20%5Ccdots%20+%20p_1)%20%5Cepsilon%20%5C%5C%0A&amp;=%20f(a)%20+%20f'(a)%20%5Cepsilon%0A%5Cend%7Balign*%7D"> and indeed it does!</p>
</section>
<section id="other-functions" class="level2">
<h2 class="anchored" data-anchor-id="other-functions">Other functions</h2>
<p>Maybe we can actually make a stronger claim: does this property holds for all infinitely differentiable functions. So, let <img src="https://latex.codecogs.com/png.latex?f"> be such a function evaluated at the dual number <img src="https://latex.codecogs.com/png.latex?a%20+%20c%20%5Cepsilon"> (note that the coefficient for the dual part need not be 1 anymore). Then we can use the taylor series expansion of <img src="https://latex.codecogs.com/png.latex?f"> to write <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(a%20+%20c%5Cepsilon)%20&amp;=%20%5Csum_%7Bn%20=%200%7D%5E%5Cinfty%20%5Cfrac%7Bf%5E%7B(n)%7D%20(a)%7D%7Bn!%7D%20((a%20+%20c%5Cepsilon)%20-%20a)%5En%20%5C%5C%0A&amp;=%20%5Csum_%7Bn%20=%200%7D%5E%5Cinfty%20%5Cfrac%7Bf%5E%7B(n)%7D%20(a)%7D%7Bn!%7D%20(c%5Cepsilon)%5En%20%5C%5C%0A&amp;=%20%5Cfrac%7Bf%5E%7B(0)%7D%20(a)%7D%7B0!%7D%20(c%5Cepsilon)%5E0%20+%20%5Cfrac%7Bf%5E%7B(1)%7D%20(a)%7D%7B1!%7D%20(c%5Cepsilon)%5E1%20+%20%5Csum_%7Bn%20=%202%7D%5E%5Cinfty%20%5Cfrac%7Bf%5E%7B(n)%7D%20(a)%7D%7Bn!%7D%20(c%5Cepsilon)%5En%20%5C%5C%0A&amp;%20f(a)%20+%20f'(a)%20c%20%5Cepsilon%0A%5Cend%7Balign*%7D"></p>
<p>and again, it does!</p>
<p>But what about composition of functions? Let <img src="https://latex.codecogs.com/png.latex?f,%20g"> be functions extended to dual numbers such that <img src="https://latex.codecogs.com/png.latex?f(a%20+%20c%20%5Cepsilon)%20=%20f(a)%20+%20f'(a)%20c%20%5Cepsilon"> and <img src="https://latex.codecogs.com/png.latex?g(a%20+%20c%20%5Cepsilon)%20=%20g(a)%20+%20g'(a)%20c%20%5Cepsilon">. Then, note that: <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0Af(g(a+%5Cepsilon))%20&amp;=%20f(g(a)%20+%20g'(a)%5Cepsilon)%20%5C%5C%0A&amp;=%20f(g(a))%20+%20f'(g(a))%20%5Ccdot%20g'(a)%20%5Cepsilon%20%5C%5C%0A%5Cend%7Balign*%7D"> and notice that the dual component <img src="https://latex.codecogs.com/png.latex?f'(g(a))%20%5Ccdot%20g'(a)"> is exactly the chain rule of derivatives! So, now we can imagine all sorts of complicated functions like <img src="https://latex.codecogs.com/png.latex?%0Af(x)%20=%20%5Csin(e%5E%7Bx%5E2%20+%201%7D)%0A"> and by using the dual number representation, we can compute both the function value and its derivative in a single forward pass through the function.</p>
</section>
<section id="closing-thoughts" class="level2">
<h2 class="anchored" data-anchor-id="closing-thoughts">Closing thoughts</h2>
<p>What I find most beautiful about dual numbers is how they transform the problem of differentiation from a difficult limiting process <img src="https://latex.codecogs.com/png.latex?%0Af'(x)%20=%20%5Clim_%7Bh%20%5Cto%200%7D%20%5Cfrac%7Bf(x+h)%20-%20f(x)%7D%7Bh%7D%0A"> into a problem of pure algebraic manipulation. This is incredibly beautiful because limits are (arguably) one of the ugliest tools in mathematics, and turning it into a formulation of abstract algebra is extremely satisfying.</p>
<p>While we gained zero divisors in dual numbers, what we got in return makes up for it: a computational method for computing derivatives that is exact (no truncation error like finite differences) and efficient (requires roughly the same number of operations as computing <img src="https://latex.codecogs.com/png.latex?f"> itself). This is why dual numbers, despite being a somewhat obscure mathematical structure, power automatic differentiation systems used in training neural networks.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-Penn2022" class="csl-entry">
Penn, Michael. 2022. <span>“The Strange Cousin of the Complex Numbers – the Dual Numbers.”</span>
</div>
</div></section></div> ]]></description>
  <category>math</category>
  <guid>https://csuraparaju.github.io/posts/dual-numbers/</guid>
  <pubDate>Tue, 08 Apr 2025 04:00:00 GMT</pubDate>
</item>
<item>
  <title>Sending Messages over Noisy Channels</title>
  <dc:creator>Krish Suraparaju</dc:creator>
  <link>https://csuraparaju.github.io/posts/noisy-channels/</link>
  <description><![CDATA[ 





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>A fundamental problem in electrical engineering is sending messages over noisy channels. For example, all messages sent over the internet have to eventually be transmitted over physical channels (copper wires or fiber optic cables), and these channels can be damaged by the elements (eg. <a href="https://www.business-reporter.co.uk/management/sharks-ate-our-data">sharks</a>)</p>
<p>I recently came across a method to reduce this problem to a purely mathematical one: the sphere packing problem, which aims to find the densest packing of non-overlapping <img src="https://latex.codecogs.com/png.latex?n"> dimensional spheres in a given space.</p>
</section>
<section id="signals-and-code" class="level2">
<h2 class="anchored" data-anchor-id="signals-and-code">Signals and Code</h2>
<p>But first, let’s define the noisy channel problem more formally. Let <img src="https://latex.codecogs.com/png.latex?T%20%3E%200"> be a fixed length of time corresponding to the length of a signal transmission.</p>
<p>A signal is a continuous function <img src="https://latex.codecogs.com/png.latex?s%20:%20%5B0,%20T%5D%20%5Cto%20%5Cmathbb%7BR%7D,"> where <img src="https://latex.codecogs.com/png.latex?s(t)"> is the amplitude of the signal at time <img src="https://latex.codecogs.com/png.latex?t">, and the frequencies do not surpass some fixed limit <img src="https://latex.codecogs.com/png.latex?W">. Think of <img src="https://latex.codecogs.com/png.latex?s(t)"> as the voltage of the signal at time <img src="https://latex.codecogs.com/png.latex?t"> (for copper wires), or the intensity of a light signal at time <img src="https://latex.codecogs.com/png.latex?t"> (for fiber optic cables).</p>
<p>A code is a finite set of signals <img src="https://latex.codecogs.com/png.latex?%5C%7Bs_1,%20s_2,%20%5Cldots,%20s_n%5C%7D."> This can be thought of as a symbolic alphabet for two computers to communicate over a channel. A simple example of a code is <img src="https://latex.codecogs.com/png.latex?%0A%5C%7B%20s_1(t)%20=%201,%5C;%20s_2(t)%20=%20-1%20%5C%7D,%0A"> which can be used to send binary messages over a channel.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">Shannon–Nyquist Sampling Theorem</a> states that any signal <img src="https://latex.codecogs.com/png.latex?s(t)"> with frequencies less than <img src="https://latex.codecogs.com/png.latex?W"> can be uniquely represented by a finite set of samples <img src="https://latex.codecogs.com/png.latex?%0A%5Cleft%5C%7B%20s(0),%20s%5C!%5Cleft(%5Ctfrac%7B1%7D%7BW%7D%5Cright),%20s%5C!%5Cleft(%5Ctfrac%7B1%7D%7B2W%7D%5Cright),%20%5Cldots,%20s%5C!%5Cleft(%5Ctfrac%7Bn-1%7D%7B2W%7D%5Cright)%20%5Cright%5C%7D,%0A"> where <img src="https://latex.codecogs.com/png.latex?n%20=%202WT">. This means that we can represent any signal <img src="https://latex.codecogs.com/png.latex?s(t)"> as a vector <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D%20%5Cin%20%5Cmathbb%7BR%7D%5En,"> and any code as a finite subset <img src="https://latex.codecogs.com/png.latex?C%20%5Csubseteq%20%5Cmathbb%7BR%7D%5En">, where each element of <img src="https://latex.codecogs.com/png.latex?C"> represents a signal.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="sampling.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="https://csuraparaju.github.io/posts/noisy-channels/sampling.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></a></p>
</figure>
</div>
<p>The continuous signal above <img src="https://latex.codecogs.com/png.latex?S(t)"> represented by the discrete samples <img src="https://latex.codecogs.com/png.latex?S_i">. Therefore, we will represent a signal as a vector in the remaining discussion.</p>
</section>
<section id="the-noisy-channel" class="level2">
<h2 class="anchored" data-anchor-id="the-noisy-channel">The Noisy Channel</h2>
<p>In the real world, the sent signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> is almost never the same as the received signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D">. This is because the channel introduces noise, which we model as a random perturbation in the input.</p>
<p>Formally, we assume that the received signal is <img src="https://latex.codecogs.com/png.latex?%0A%5Cvec%7Br%7D%20=%20%5Cvec%7Bs%7D%20+%20%5Cvec%7Bz%7D,%0A"> where <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bz%7D"> is a random vector with Gaussian entries (each <img src="https://latex.codecogs.com/png.latex?z_i%20%5Csim%20%5Cmathcal%7BN%7D(0,%20%5Csigma%5E2)"> and is i.i.d). If the receiver wants to determine which signal was sent, a natural decoding strategy is nearest-neighbor decoding: <img src="https://latex.codecogs.com/png.latex?%0A%5Chat%7B%5Cvec%7Bs%7D%7D%20=%20%5Cunderset%7B%5Cvec%7Bs_i%7D%20%5Cin%20C%7D%7B%5Ctext%7Bargmin%7D%7D%20%5C%7C%20%5Cvec%7Br%7D%20-%20%5Cvec%7Bs_i%7D%20%5C%7C_2.%0A"></p>
<p>However, if two signals in the code are too close together, noise may make decoding ambiguous. For example, in the following situation:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="close_signals.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="https://csuraparaju.github.io/posts/noisy-channels/close_signals.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
<p>which signal does <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> correspond to? Both <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_1%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_2%7D"> are equally likely.</p>
<p><br>
</p>
<p>To solve this problem, remember that we assumed <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D%20=%20%5Cvec%7Bs%7D%20+%20%5Cvec%7Bz%7D"> and that each <img src="https://latex.codecogs.com/png.latex?z_i%20%5Csim%20%5Cmathcal%7BN%7D(0,%20%5Csigma%5E2)">. A fundamental property of the Gaussian distribution is that <img src="https://latex.codecogs.com/png.latex?%0A%5Cmathbb%7BP%7D%5B-3%20%5Csigma%20%5Cleq%20z_i%20%5Cleq%203%20%5Csigma%5D%20%5Capprox%2099.7%5C%25%0A"> So, we can use this to figure out a bound on the distance between <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> and <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> with high probability. In the worst-case, each component is such that <img src="https://latex.codecogs.com/png.latex?%7Cz_i%7C%20=%203%20%5Csigma">. Since we have <img src="https://latex.codecogs.com/png.latex?n"> components, this means that <img src="https://latex.codecogs.com/png.latex?%5Cbegin%7Balign*%7D%0A%5C%7C%20%5Cvec%7Br%7D%20-%20%5Cvec%7Bs%7D%20%5C%7C_2%20=%20%20%5C%7C%20%5Cvec%7Bz%7D%5C%7C_2%20&amp;=%20%5Csqrt%7B%5Csum_%7Bi%20=%201%7D%5E%7Bn%7D%20z_i%5E2%7D%20%5C%5C%20&amp;%5Cleq%5Csqrt%7B%5Csum_%7Bi%20=%201%7D%5E%7Bn%7D%20(3%20%5Csigma)%5E2%7D%20%5C%5C%20&amp;%5Cleq%20%5Csqrt%7Bn%20%5Ccdot%209%20%5Csigma%5E2%7D%20%5C%5C%20&amp;%5Cleq%203%20%5Csigma%20%5Csqrt%7Bn%7D%0A%5Cend%7Balign*%7D"> with probability <img src="https://latex.codecogs.com/png.latex?99.7%5C%25">. This means that the worst-case noise can push the received signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> up to a distance of <img src="https://latex.codecogs.com/png.latex?3%20%5Csigma%20%5Csqrt%7Bn%7D"> away from the true signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D">. This creates a sphere of radius <img src="https://latex.codecogs.com/png.latex?3%20%5Csigma%20%5Csqrt%7Bn%7D"> around <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_1%7D">. To make our decoding as unambiguous as possible, we need to ensure that even when noise pushes <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Br%7D"> to the edge of this sphere, it is still closer to <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> than any other signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_2%7D%20%5Cin%20C">. But signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs_2%7D"> also has a sphere of radius <img src="https://latex.codecogs.com/png.latex?3%20%5Csigma%20%5Csqrt%7Bn%7D"> around it. Therefore, to guarantee that two spheres don’t overlap, the minimum distance between any two signals must be at least <img src="https://latex.codecogs.com/png.latex?6%20%5Csigma%20%5Csqrt%7Bn%7D"></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="packed_signal.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="https://csuraparaju.github.io/posts/noisy-channels/packed_signal.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
</section>
<section id="dense-sphere-packing" class="level2">
<h2 class="anchored" data-anchor-id="dense-sphere-packing">Dense Sphere packing</h2>
<p>Now, you might ask: why don’t we just pick signals that are as far apart as possible? For example, we could place just two signals at opposite ends of our signal space.</p>
<p>But recall that a signal <img src="https://latex.codecogs.com/png.latex?%5Cvec%7Bs%7D"> represents the amplitude or voltage of a message over time. Physicists have told us the power of a signal is proportional to the square of its amplitude: <img src="https://latex.codecogs.com/png.latex?%0A%5Ctext%7BPower%7D%20%5Cpropto%20%5C%7C%5Cvec%7Bs%7D%5C%7C_2%5E2%20=%20%5Csum_%7Bi=1%7D%5E%7Bn%7D%20s_i%5E2%0A"></p>
<p>In practice, we cannot transmit signals with arbitrarily large power. There are physical limits on how much voltage we can apply to a copper wire and how much light we can send through a fiber optic cable. If we set a maximum power budget <img src="https://latex.codecogs.com/png.latex?P">, then all our signals must satisfy <img src="https://latex.codecogs.com/png.latex?%0A%5C%7C%5Cvec%7Bs%7D%5C%7C_2%5E2%20%5Cleq%20nP%20%5Cquad%20%5CLongrightarrow%20%5Cquad%20%5C%7C%5Cvec%7Bs%7D%5C%7C_2%20%5Cleq%20%5Csqrt%7BnP%7D%0A"></p>
<p>This means all our signals must lie within a sphere of radius <img src="https://latex.codecogs.com/png.latex?%5Csqrt%7BnP%7D"> in <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5En">, which is a compact region. The more signals we can fit in this region, the more information we can transmit per signal. For example, a code with 2 signals transmits only 1 bit per transmission, but a code with 256 signals transmits 8 bits per transmission.</p>
<p>At the same time, each signal needs a sphere of radius <img src="https://latex.codecogs.com/png.latex?3%5Csigma%5Csqrt%7Bn%7D"> around it to ensure correct decoding with probability <img src="https://latex.codecogs.com/png.latex?99.7%5C%25">. This is exactly the sphere packing problem: what is the maximum number of non-overlapping spheres of radius <img src="https://latex.codecogs.com/png.latex?3%5Csigma%5Csqrt%7Bn%7D"> that we can pack inside a sphere of radius <img src="https://latex.codecogs.com/png.latex?%5Csqrt%7BnP%7D">? Each sphere center represents a signal in our code, and finding the densest packing directly gives us the code that can transmit the most information reliably. Therefore, the problem of designing optimal codes for noisy channels reduces to an entirely abstract problem in math.</p>


</section>

 ]]></description>
  <category>math</category>
  <category>ece</category>
  <guid>https://csuraparaju.github.io/posts/noisy-channels/</guid>
  <pubDate>Wed, 25 Dec 2024 05:00:00 GMT</pubDate>
</item>
<item>
  <title>Metric Spaces, dimension reduction, and Bourgain Embeddings</title>
  <dc:creator>Krish Suraparaju</dc:creator>
  <link>https://csuraparaju.github.io/posts/bourgain-embedding/</link>
  <description><![CDATA[ 





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Metric embeddings and dimension reduction are important tools in computer science and mathematics for solving the curse of dimensionality. In this post, I want to examine the Bourgain embedding, which shows that any finite metric space can be embedded into an Euclidean metric space space with <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20%E2%81%A1n)"> distortion. While Bourgain embeddings are very impractical (the constant factors in the big - O are huge and the “reduced” dimensions is still high), it is an important result that shows us that no matter how “horrible” the initial metric space is, we can be achieve a distortion factor of <img src="https://latex.codecogs.com/png.latex?O(%5Clog%20n)">.</p>
<p><em>Note</em>: I’ve written this post assuming that the reader has at least taken an undergraduate discrete math course. However, I will still define the important objects we will be using today.</p>
<section id="metric-spaces" class="level3">
<h3 class="anchored" data-anchor-id="metric-spaces">Metric Spaces</h3>
<p>A metric space <img src="https://latex.codecogs.com/png.latex?(X,%20d)"> is a set <img src="https://latex.codecogs.com/png.latex?X"> with a distance function <img src="https://latex.codecogs.com/png.latex?d:%20X%20%5Ctimes%20X%20%5Cto%20%5Cmathbb%7BR%7D">. The distance function satisfies the following properties:</p>
<ol type="1">
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20%5Cgeq%200"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y%20%5Cin%20X"></li>
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20=%200"> if and only if <img src="https://latex.codecogs.com/png.latex?x%20=%20y"></li>
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20=%20d(y,%20x)"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y%20%5Cin%20X"></li>
<li><img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20%5Cleq%20d(x,%20z)%20+%20d(z,%20y)"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y,%20z%20%5Cin%20X"></li>
</ol>
<p>Some examples of metric spaces:</p>
<ol type="1">
<li>A weighted graph <img src="https://latex.codecogs.com/png.latex?G%20=%20(V,%20E)"> with <img src="https://latex.codecogs.com/png.latex?X%20=%20V"> and <img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20="> length of the shortest path between <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y">.</li>
<li>The DNA space with <img src="https://latex.codecogs.com/png.latex?X%20=%20%5C%7BA,%20C,%20G,%20T%5C%7D%5En"> and <img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20="> number of positions where <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y"> differ.</li>
<li>The Euclidean space <img src="https://latex.codecogs.com/png.latex?%5Cmathbb%7BR%7D%5En"> with <img src="https://latex.codecogs.com/png.latex?X%20=%20%5Cmathbb%7BR%7D%5En"> and <img src="https://latex.codecogs.com/png.latex?d(x,%20y)%20=%20%5C%7Cx%20-%20y%5C%7C_2%20=%20%5Csqrt%7B(x_1%20-%20y_1)%5E2%20+%20%5Ccdots%20+%20(x_n%20-%20y_n)%5E2%7D">.</li>
</ol>
</section>
<section id="maps-embeddings-and-distortions" class="level3">
<h3 class="anchored" data-anchor-id="maps-embeddings-and-distortions">Maps, Embeddings and Distortions</h3>
<p>A map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20Y"> between two metric spaces <img src="https://latex.codecogs.com/png.latex?(X,%20d_X)"> and <img src="https://latex.codecogs.com/png.latex?(Y,%20d_Y)"> is called an embedding that maps elements of <img src="https://latex.codecogs.com/png.latex?X"> to elements of <img src="https://latex.codecogs.com/png.latex?Y">.</p>
<p>The embedding is said to be distance-preserving (isometric) if <img src="https://latex.codecogs.com/png.latex?d_Y(f(x),%20f(y))%20=%20d_X(x,%20y)"> for all <img src="https://latex.codecogs.com/png.latex?x,%20y%20%5Cin%20X">. However, very rarely do we have distance-preserving embeddings between metric spaces. Instead, we often consider embeddings that are “almost” distance-preserving.</p>
<p>An embedding with distortion of <img src="https://latex.codecogs.com/png.latex?%5Calpha"> of a metric space <img src="https://latex.codecogs.com/png.latex?(X,%20d_X)"> into another metric space <img src="https://latex.codecogs.com/png.latex?(Y,%20d_Y)"> is a map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20Y"> such that there exists constant <img src="https://latex.codecogs.com/png.latex?r%20%3E%200"> for which <img src="https://latex.codecogs.com/png.latex?r%20%5Ccdot%20d_X(x,%20y)%20%5Cleq%20d_Y(f(x),%20f(y))%20%5Cleq%20%5Calpha%20r%20%5Ccdot%20d_X(x,%20y)%20%5Ctext%7B%20for%20all%20%7D%20x,%20y%20%5Cin%20X"> The distortion of an embedding is the smallest <img src="https://latex.codecogs.com/png.latex?%5Calpha"> for which such a map exists.</p>
<p>Because we are working in a finite set for now, we can equivalently define the distortion in terms of the contraction and expansion. Given a map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20Y">, let:</p>
<p><img src="https://latex.codecogs.com/png.latex?%5Ctext%7BContraction%7D(f)%20=%20%5Cmax_%7Bx,%20y%20%5Cin%20X%7D%20%5Cfrac%7Bd_Y(f(x),%20f(y))%7D%7Bd_X(x,%20y)%7D"></p>
<p><img src="https://latex.codecogs.com/png.latex?%20%5Ctext%7BExpansion%7D(f)%20=%20%5Cmax_%7Bx,%20y%20%5Cin%20X%7D%20%5Cfrac%7Bd_X(x,%20y)%7D%7Bd_Y(f(x),%20f(y))%7D"></p>
<p>Define the distortion of <img src="https://latex.codecogs.com/png.latex?f"> as <img src="https://latex.codecogs.com/png.latex?%5Calpha%20=%20%5Ctext%7BExpansion%7D(f)%5Ccdot%5Ctext%7BContraction%7D(f)">.</p>
</section>
</section>
<section id="bourgain-embedding" class="level2">
<h2 class="anchored" data-anchor-id="bourgain-embedding">Bourgain Embedding</h2>
<p>Given an arbitrary finite metric space <img src="https://latex.codecogs.com/png.latex?(X,%20d)"> with <img src="https://latex.codecogs.com/png.latex?n"> points, Bourgain’s theorem says that there exists a map <img src="https://latex.codecogs.com/png.latex?f:%20X%20%5Cto%20%5Cmathbb%7BR%7D%5Ek"> such that the distortion of <img src="https://latex.codecogs.com/png.latex?f"> is <img src="https://latex.codecogs.com/png.latex?%5Calpha%20%5Cin%20O(%5Clog%20n)">, and <img src="https://latex.codecogs.com/png.latex?k%20%5Cin%20O(%5Clog%5E2%20n)">. The proof of this theorem is beyond the scope of this post, but it is a constructive proof so there is a natural algorithm that arises from the proof which we can implement.</p>
<p>The Bourgain embedding algorithm is as follows <span class="citation" data-cites="Ye2023">(Ye 2023)</span>:</p>
<ol type="1">
<li><p>Let <img src="https://latex.codecogs.com/png.latex?c"> be a sufficiently large constant, and let <img src="https://latex.codecogs.com/png.latex?%5Clog(n)"> denote the base-2 logarithm of <img src="https://latex.codecogs.com/png.latex?n">.</p></li>
<li><p>For each point <img src="https://latex.codecogs.com/png.latex?x%20%5Cin%20X">, define its embedding vector <img src="https://latex.codecogs.com/png.latex?f(x)"> in the following steps:</p>
<ul>
<li>For <img src="https://latex.codecogs.com/png.latex?i%20%5Cin%20%5C%7B1,%202,%20%5Cdots,%20%5Clceil%20%5Clog_2(n)%20%5Crceil%20%5C%7D">:
<ul>
<li>For <img src="https://latex.codecogs.com/png.latex?j%20%5Cin%20%5C%7B1,%202,%20%5Cdots,%20c%20%5Ccdot%20%5Clceil%20%5Clog_2(n)%20%5Crceil%20%5C%7D">:
<ol type="1">
<li>Choose a random subset <img src="https://latex.codecogs.com/png.latex?S_%7Bij%7D%20%5Csubseteq%20X">, where each <img src="https://latex.codecogs.com/png.latex?y%20%5Cin%20X"> is included in <img src="https://latex.codecogs.com/png.latex?S_%7Bij%7D"> with probability <img src="https://latex.codecogs.com/png.latex?2%5E%7B-i%7D">.</li>
<li>Compute <img src="https://latex.codecogs.com/png.latex?d(x,%20S_%7Bij%7D)">, the minimum distance from <img src="https://latex.codecogs.com/png.latex?x"> to any point in <img src="https://latex.codecogs.com/png.latex?S_%7Bij%7D">.</li>
</ol></li>
<li>Construct the embedding vector: <img src="https://latex.codecogs.com/png.latex?f(x)%20=%20%5Clangle%20d(x,%20S_%7B11%7D),%20d(x,%20S_%7B12%7D),%20%5Cdots,%20d(x,%20S_%7B%5Clceil%20%5Clog_2(n)%20%5Crceil%20%5Ccdot%20c%20%5Ccdot%20%5Clceil%20%5Clog_2(n)%20%5Crceil%7D)%5Crangle."></li>
</ul></li>
</ul></li>
</ol>
<p>An intuition for the algorithm is that it creates a “fingerprint” for each point by measuring its distance to random subsets of the space at multiple scales. So, for each point, we answer the question:</p>
<ul>
<li>“How far am I from a randomly chosen half of all points?”</li>
<li>“How far am I from a randomly chosen quarter of all points?”</li>
<li>“How far am I from a randomly chosen eighth of all points?”</li>
<li>…</li>
</ul>
<p>Why does this capture distance information? Imagine two points <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y"> in our original metric space. If they are close, they’ll have similar distances to most random subsets. When we sample a random subset <img src="https://latex.codecogs.com/png.latex?S">, chances are the nearest point in <img src="https://latex.codecogs.com/png.latex?S"> to <img src="https://latex.codecogs.com/png.latex?x"> will also be close to <img src="https://latex.codecogs.com/png.latex?y"> so, the embedded distances will also be similar.</p>
<p>However, if <img src="https://latex.codecogs.com/png.latex?x"> and <img src="https://latex.codecogs.com/png.latex?y"> are far apart, then at some scale, we’ll sample points that “separate” them. That is, there will be random subsets where <img src="https://latex.codecogs.com/png.latex?x"> is close to some sampled point but <img src="https://latex.codecogs.com/png.latex?y"> is far from all sampled points (or vice versa). This creates a difference in their fingerprints that the algorithm can capture when construction the embedding.</p>
<p>Note that in practice, this algorithm can be really bad because of the big-O constants. For example, if <img src="https://latex.codecogs.com/png.latex?X%20=%20%5Cmathbb%7BR%7D%5E%7B1000%7D">, and we chose <img src="https://latex.codecogs.com/png.latex?c%20=%20100"> (for less distortion), then the reduced dimension <img src="https://latex.codecogs.com/png.latex?k%20=%20100%20%5Ccdot%20%5Clog%5E2%7B1000%7D%20=%20900">. This is an improvement over the <img src="https://latex.codecogs.com/png.latex?1000"> dimensional space, but just barely.</p>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>Let’s implement this in python using numpy so we can vectorize parts of the code.</p>
<div id="3652f975" class="cell" data-execution_count="1">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> numpy <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> np</span>
<span id="cb1-2"></span>
<span id="cb1-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> bourgain_embedding(dist_mat, c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>):</span>
<span id="cb1-4">    n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">len</span>(dist_mat)</span>
<span id="cb1-5"></span>
<span id="cb1-6">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>:</span>
<span id="cb1-7">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> np.zeros((n, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>))</span>
<span id="cb1-8"></span>
<span id="cb1-9">    log_n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">int</span>(np.ceil(np.log2(n)))</span>
<span id="cb1-10">    k <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> log_n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> log_n</span>
<span id="cb1-11">    max_dist <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>()</span>
<span id="cb1-12"></span>
<span id="cb1-13">    f_x <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.zeros((n, k))</span>
<span id="cb1-14"></span>
<span id="cb1-15">    j <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span></span>
<span id="cb1-16">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, log_n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>):</span>
<span id="cb1-17">        p <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span> <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">**</span> (<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span>i)</span>
<span id="cb1-18">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> _ <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(c <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> log_n):</span>
<span id="cb1-19">            subset_mask <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.random.rand(n) <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&lt;</span> p</span>
<span id="cb1-20"></span>
<span id="cb1-21">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> np.<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">any</span>(subset_mask):</span>
<span id="cb1-22">                f_x[:, j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> max_dist</span>
<span id="cb1-23">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">else</span>:</span>
<span id="cb1-24">                f_x[:, j] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat[:, subset_mask].<span class="bu" style="color: null;
background-color: null;
font-style: inherit;">min</span>(axis<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb1-25">            j <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span></span>
<span id="cb1-26"></span>
<span id="cb1-27">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> f_x</span></code></pre></div></div>
</div>
<p>We can plot the distortion of this algorithm on a randomly generated metric space, as a function of <img src="https://latex.codecogs.com/png.latex?n"> to see the logarithmic curve.</p>
<div id="1e3f76cd" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">import</span> matplotlib.pyplot <span class="im" style="color: #00769E;
background-color: null;
font-style: inherit;">as</span> plt</span>
<span id="cb2-2"></span>
<span id="cb2-3"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> distortion(dist_mat, emb):</span>
<span id="cb2-4">    n <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat.shape[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb2-5">    max_expand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span></span>
<span id="cb2-6">    max_contract <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="fl" style="color: #AD0000;
background-color: null;
font-style: inherit;">0.0</span></span>
<span id="cb2-7"></span>
<span id="cb2-8">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> i <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(n):</span>
<span id="cb2-9">        <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> j <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">range</span>(i <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">+</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>, n):</span>
<span id="cb2-10">            d0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> dist_mat[i, j]</span>
<span id="cb2-11">            d1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.linalg.norm(emb[i] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> emb[j], <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">ord</span><span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1</span>)</span>
<span id="cb2-12"></span>
<span id="cb2-13">            <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> d0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">and</span> d1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">&gt;</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>:</span>
<span id="cb2-14">                max_expand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(max_expand, d1 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> d0)</span>
<span id="cb2-15">                max_contract <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="bu" style="color: null;
background-color: null;
font-style: inherit;">max</span>(max_contract, d0 <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> d1)</span>
<span id="cb2-16"></span>
<span id="cb2-17">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> max_expand <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> max_contract</span>
<span id="cb2-18"></span>
<span id="cb2-19"><span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">def</span> gen_random_space(n, d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, seed<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>):</span>
<span id="cb2-20">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">if</span> seed <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">is</span> <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">not</span> <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>:</span>
<span id="cb2-21">        np.random.seed(seed)</span>
<span id="cb2-22">    X <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.random.randn(n, d)</span>
<span id="cb2-23">    diff <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> X[:, <span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>, :] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">-</span> X[<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">None</span>, :, :]</span>
<span id="cb2-24">    <span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">return</span> np.linalg.norm(diff, axis<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">2</span>)</span>
<span id="cb2-25"></span>
<span id="cb2-26">c_fixed <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">8</span></span>
<span id="cb2-27">ns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">350</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">750</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>]</span>
<span id="cb2-28"></span>
<span id="cb2-29">distortions <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb2-30"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> n <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> ns:</span>
<span id="cb2-31">    dist_mat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gen_random_space(n, d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, seed<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb2-32">    emb <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> bourgain_embedding(dist_mat, c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>c_fixed)</span>
<span id="cb2-33">    distortions.append(distortion(dist_mat, emb))</span>
<span id="cb2-34"></span>
<span id="cb2-35">log_ns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> np.log(ns)</span>
<span id="cb2-36">log_ns_scaled <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> log_ns <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">/</span> log_ns[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>] <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">*</span> distortions[<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>]</span>
<span id="cb2-37"></span>
<span id="cb2-38">plt.figure(figsize<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>))</span>
<span id="cb2-39">plt.plot(ns, distortions, marker<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'o'</span>, label<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain distortion"</span>)</span>
<span id="cb2-40">plt.plot(ns, log_ns_scaled, linestyle<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'--'</span>, label<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r"scaled </span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="er" style="color: #AD0000;
background-color: null;
font-style: inherit;">\</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">log n</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb2-41"></span>
<span id="cb2-42">plt.xlabel(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r"</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">n</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb2-43">plt.ylabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Distortion"</span>)</span>
<span id="cb2-44">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain embedding distortion vs log n"</span>)</span>
<span id="cb2-45">plt.grid(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb2-46">plt.legend()</span>
<span id="cb2-47">plt.tight_layout()</span>
<span id="cb2-48">plt.show()</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://csuraparaju.github.io/posts/bourgain-embedding/index_files/figure-html/cell-3-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Note that the variable <img src="https://latex.codecogs.com/png.latex?c"> is a hyper-parameter to this algorithm, and we can observe distortion as a function of <img src="https://latex.codecogs.com/png.latex?c"> as well.</p>
<div id="66952c2b" class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb3" style="background: #f1f3f5;"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1">n_fixed <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span></span>
<span id="cb3-2">cs <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> [<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">10</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">50</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">100</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">400</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">500</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">600</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">700</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">800</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">900</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1000</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1100</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1200</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">1300</span>]</span>
<span id="cb3-3"></span>
<span id="cb3-4">distortions <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> []</span>
<span id="cb3-5"><span class="cf" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">for</span> c <span class="kw" style="color: #003B4F;
background-color: null;
font-weight: bold;
font-style: inherit;">in</span> cs:</span>
<span id="cb3-6">    dist_mat <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> gen_random_space(n_fixed, d<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>, seed<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">0</span>)</span>
<span id="cb3-7">    emb <span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span> bourgain_embedding(dist_mat, c<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>c)</span>
<span id="cb3-8">    distortions.append(distortion(dist_mat, emb))</span>
<span id="cb3-9"></span>
<span id="cb3-10"></span>
<span id="cb3-11">plt.figure(figsize<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span>(<span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">7</span>, <span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">5</span>))</span>
<span id="cb3-12">plt.plot(cs, distortions, marker<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">'o'</span>, label<span class="op" style="color: #5E5E5E;
background-color: null;
font-style: inherit;">=</span><span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain distortion"</span>)</span>
<span id="cb3-13"></span>
<span id="cb3-14">plt.xlabel(<span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">r"</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">c</span><span class="dv" style="color: #AD0000;
background-color: null;
font-style: inherit;">$</span><span class="vs" style="color: #20794D;
background-color: null;
font-style: inherit;">"</span>)</span>
<span id="cb3-15">plt.ylabel(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Distortion"</span>)</span>
<span id="cb3-16">plt.title(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"Bourgain embedding distortion vs c"</span>)</span>
<span id="cb3-17">plt.grid(<span class="va" style="color: #111111;
background-color: null;
font-style: inherit;">True</span>)</span>
<span id="cb3-18">plt.legend()</span>
<span id="cb3-19">plt.tight_layout()</span>
<span id="cb3-20">plt.show()</span></code></pre></div></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="https://csuraparaju.github.io/posts/bourgain-embedding/index_files/figure-html/cell-4-output-1.png" width="662" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0">
<div id="ref-Ye2023" class="csl-entry">
Ye, Richard. 2023. <span>“Bourgain’s Embedding Theorem, Johnson-Lindenstrauss Lemma, and the Sparsest Cut Problem.”</span>
</div>
</div></section></div> ]]></description>
  <category>math</category>
  <guid>https://csuraparaju.github.io/posts/bourgain-embedding/</guid>
  <pubDate>Fri, 20 Dec 2024 05:00:00 GMT</pubDate>
</item>
</channel>
</rss>
