<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Krish Suraparaju">
<meta name="dcterms.date" content="2025-10-15">

<title>The Metropolis-Hastings Algorithm for Sampling – Krish’s blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/videojs/video.min.js"></script>
<link href="../../site_libs/quarto-contrib/videojs/video-js.css" rel="stylesheet">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Krish’s blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Krish Suraparaju</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/csuraparaju"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/krish-suraparaju/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">The Metropolis-Hastings Algorithm for Sampling</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">math</div>
                <div class="quarto-category">cs</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Krish Suraparaju </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 15, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In a previous blog <a href="https://csuraparaju.github.io/posts/sampling/">post</a>, I discussed various algorithms for sampling from a probability distribution <span class="math inline">\(\pi\)</span>. These algorithms all made a simple assumption: we can compute <span class="math inline">\(\pi(x)\)</span> efficiently for all <span class="math inline">\(x\)</span> in our sample space <span class="math inline">\(\chi\)</span>. However, this assumption might be too strong for certain cases. What if computing <span class="math inline">\(\pi(x)\)</span> is computationally intractable? We can’t use the methods developed in that post. What do we do instead?</p>
</section>
<section id="protein-folding" class="level2">
<h2 class="anchored" data-anchor-id="protein-folding">Protein Folding</h2>
<p>As an example of a situation where <span class="math inline">\(\pi\)</span> is uncomputable, let’s study protein folding. You might recall that a protein is a chain of amino acids (also called residues) that folds into a certain structure. One of the simplest models for this process is the Hydrophobic-Polar (HP) lattice model, where we have a chain of <span class="math inline">\(N\)</span> residues, each classified as either hydrophobic (H) which is water-repelling, or polar (P) which is water-loving. Chemistry tells us that hydrophobic residues tend to cluster together, and so the final folded structure of an acid sequence is heavily influenced by <span class="math inline">\(H\)</span> and <span class="math inline">\(P\)</span> residues. We can see this effect in the diagram below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="hydrophobic_collapse.png" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="hydrophobic_collapse.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:50.0%"></a></p>
</figure>
</div>
<p>On the left is an unfolded amino acid sequence, with hydrophobic residues in black and polar particles in white. Observe that after folding, the hydrophobic residues clustered together on the “inside” of the protein, while the polar residues are closer to the surface of the protein.</p>
<p>Mathematically, the folded structure of this amino acid can be modeled as a graph on a 2D integer lattice where each residue is mapped to a point in space. However, we can’t just consider any arbitrary graph. To keep this model realistic, we need to have the restriction that adjacent amino acids in the sequence are adjacent in the lattice (since the amino acid sequence cannot be permuted when folding), and no two residues occupy the same point in space. We can define this more formally as follows:</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>HP Model
</div>
</div>
<div class="callout-body-container callout-body">
<p>An amino acid sequence is a string <span class="math inline">\(s \in \{H, P\}^N\)</span> of length <span class="math inline">\(N\)</span>. A folded configuration of this sequence is a function <span class="math inline">\(\omega : [1, \cdots, N] \to \mathbb{Z}^2\)</span> where <span class="math inline">\(\omega(i)\)</span> gives the position of the <span class="math inline">\(i\)</span>-th amino acid in <span class="math inline">\(s\)</span> on the lattice, such that</p>
<ul>
<li><span class="math inline">\(||\omega(i) - \omega(i+1)||_2 = 1\)</span> for all <span class="math inline">\(1 \leq i &lt; N\)</span> (adjacent residues in the sequence are adjacent in the lattice)</li>
<li><span class="math inline">\(\omega(i) \neq \omega(j)\)</span> for all <span class="math inline">\(i \neq j\)</span> (two residues cannot occupy the same point in space)</li>
</ul>
<p>Chemistry tells us that the energy of a configuration <span class="math inline">\(\omega\)</span> depends on hydrophobic contacts. We say two residues at positions <span class="math inline">\(\omega(i)\)</span> and <span class="math inline">\(\omega(j)\)</span> are in contact if they are adjacent on the lattice but not consecutive in the sequence so that <span class="math inline">\(|i−j| &gt; 1\)</span>. This way, we only count the interactions of residues that moved around in 2D space to cluster together, rather than ones that were already next to each other. The energy is then: <span class="math display">\[E(s, \omega) = \sum_{i \sim j} E_{s_i, s_j}\]</span> where <span class="math inline">\(i \sim j\)</span> iff <span class="math inline">\(\omega(i)\)</span> is in contact with <span class="math inline">\(\omega(j)\)</span>, and <span class="math inline">\(E_{HH} = -1\)</span>, <span class="math inline">\(E_{HP} = E_{PH} = E_{PP} = 0\)</span>, so only <span class="math inline">\(HH\)</span> contacts contribute to lowering the energy, and giving us a way to quantify the clustering behavior of <span class="math inline">\(H\)</span> residues.</p>
</div>
</div>
<p>Below is an example sequence <span class="math inline">\(HPPHPH\)</span> and possible folded configurations <span class="math inline">\(\omega\)</span>. <span class="math inline">\(H\)</span> amino acids are colored green and <span class="math inline">\(P\)</span> amino acids are in silver. The configuration <span class="math inline">\(\omega\)</span> that has the minimum energy of all the listed configurations is circled in red, since it has three <span class="math inline">\(HH\)</span> contacts, most out of the others. Image courtesy of <a href="https://math.mit.edu/classes/18.417/Slides/HP-protein-prediction.pdf">MIT: 18.417</a></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="hp_model.png" class="lightbox" data-gallery="quarto-lightbox-gallery-2"><img src="hp_model.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
<p>Given this set up, our goal is to study the folded protein structure of an amino acid sequence. Specifically, we want to understand what a typical folded configuration looks like at temperature <span class="math inline">\(T\)</span>. Thermochemistry tells us that protein folding can actually be thought of sampling from a distribution proportional to the Boltzmann distribution: <span class="math display">\[
\pi_u(\omega | s) := \mathbb{P}[\omega | s] = e^{-\frac{E(s, \omega)}{k_B T}}
\]</span> where <span class="math inline">\(T\)</span> is the temperature, <span class="math inline">\(k_B\)</span> is the Boltzmann constant. To turn <span class="math inline">\(\pi_u\)</span> into a probability distribution, we need to compute a normalizing constant <span class="math display">\[
Z = \sum_{\omega}\pi_u(\omega | s)
\]</span> and define <span class="math display">\[
\pi(\omega | s) := \frac{1}{Z} \pi_u (\omega | s)
\]</span></p>
<p>We can now use the algorithm developed at the end of this <a href="https://csuraparaju.github.io/posts/sampling/">post</a> to draw samples from this distribution and understand what typical folded protein configurations look like at temperature <span class="math inline">\(T\)</span>. There’s just one problem: the normalizing constant <span class="math inline">\(Z\)</span>.</p>
</section>
<section id="intractability-of-z" class="level2">
<h2 class="anchored" data-anchor-id="intractability-of-z">Intractability of <span class="math inline">\(Z\)</span></h2>
<p>We need to compute <span class="math inline">\(\pi_u(\omega | s)\)</span> for all possible <span class="math inline">\(\omega\)</span> given a specific <span class="math inline">\(s\)</span> to find <span class="math inline">\(Z\)</span>. What could happen if the number of possible configurations is computationally intractable? In this case, it turns out that there are about <span class="math inline">\(3^N\)</span> different <span class="math inline">\(\omega\)</span>’s. This is because we can place the first residue anywhere on the lattice, and so the second residue has <span class="math inline">\(4\)</span> choices (up, down, left, right). The third residue has at most three choices (since we can’t backtrack to residue <span class="math inline">\(1\)</span>’s position), and similarly with the fourth residue. We can continue this argument for <span class="math inline">\(N\)</span> and get the rough bound <span class="math inline">\(3^N\)</span> for the number of possible configurations.</p>
<p>This is a huge number! Even if we have a relatively small amino acid sequence, with <span class="math inline">\(N = 100\)</span>, there are roughly <span class="math inline">\(3^{100}\)</span> possible configurations to try! Even our fastest computers today will take about <span class="math inline">\(10^{22}\)</span> years to finish calculating that a sum of that many terms. What’s worse is that there is no smarter way to compute <span class="math inline">\(Z\)</span>. We need to evaluate <span class="math inline">\(\pi_u\)</span> at every single <span class="math inline">\(\omega\)</span>. This makes it impossible to use our previously developed algorithms since it is hopeless to try to compute <span class="math inline">\(\pi (\omega | s)\)</span>. We need to think of another way to solve this problem.</p>
<p>If we can’t compute <span class="math inline">\(\pi(\omega | s)\)</span> directly, are there quantities that we can compute? Well, we can evaluate <span class="math inline">\(\pi_u (\omega | s)\)</span> since that just requires counting the <span class="math inline">\(HH\)</span> contacts for a single <span class="math inline">\(\omega\)</span>. Does this help us come up with a way to understand how <span class="math inline">\(\pi\)</span> looks like? Suppose we have two configurations, <span class="math inline">\(\omega\)</span> and <span class="math inline">\(\omega'\)</span>. While we don’t know their individual probabilities <span class="math inline">\(\pi(\omega | s)\)</span> or <span class="math inline">\(\pi(\omega' | s)\)</span>, observe what happens when we look at their ratio:</p>
<p><span class="math display">\[
\frac{\pi(\omega' | s)}{\pi(\omega | s)} = \frac{\pi_u(\omega' | s)/Z}{\pi_u(\omega | s)/Z} = \frac{\pi_u(\omega' | s)}{\pi_u(\omega | s)}
\]</span></p>
<p>The <span class="math inline">\(Z\)</span> terms cancel out entirely. We are left with a ratio of unnormalized weights (<span class="math inline">\(\pi_u\)</span>), which is just a simple calculation of <span class="math inline">\(HH\)</span> contacts. Now, notice that the fraction</p>
<p><span class="math display">\[
\frac{\pi(\omega' | s)}{\pi(\omega | s)}
\]</span></p>
<p>tells us the relative probability of two configurations. If this ratio is greater than <span class="math inline">\(1\)</span>, then <span class="math inline">\(\omega'\)</span> has higher probability than <span class="math inline">\(\omega'\)</span>. If it’s less than <span class="math inline">\(1\)</span> then <span class="math inline">\(\omega\)</span> has higher probability. Using this, we can compare the likelihood of two configurations.</p>
<p>This should hopefully give you an idea. Since we can’t look at the whole landscape of <span class="math inline">\(3^N\)</span> configurations to pick a perfect sample, we start with a single, arbitrary configuration <span class="math inline">\(\omega_0\)</span>. It’s almost certainly not a typical sample from <span class="math inline">\(\pi\)</span>, but that doesn’t matter yet. We want to produce a sequence of configurations <span class="math inline">\(\omega_0, \omega_1, \omega_2, \dots, \omega_t\)</span> such that, as <span class="math inline">\(t \to \infty\)</span>, the configurations look less like our arbitrary start and more like they were drawn from <span class="math inline">\(\pi\)</span>. To do this, at each step <span class="math inline">\(t\)</span>, we should propose a new candidate <span class="math inline">\(\omega'\)</span>. Then, we should decide if we should update our current sample to <span class="math inline">\(\omega'\)</span>, or keep <span class="math inline">\(\omega_t\)</span> as the candidate. But how do we make this decision?</p>
<p>Hopefully you see that we can use our ratio <span class="math display">\[\frac{\pi(\omega' | s)}{\pi(\omega_t | s)}\]</span> as a way to filter. If the ratio is high, <span class="math inline">\(\omega'\)</span> is more likely than our current state. We should probably update our sample to <span class="math inline">\(\omega'\)</span>. If the ratio is low, it means <span class="math inline">\(\omega'\)</span> is less likely. We should probably reject it and keep <span class="math inline">\(\omega_t\)</span> as our sample for this step.</p>
<p>While our initial choice <span class="math inline">\(\omega_0\)</span> might be a bad representative of the distribution, the process is self-correcting. Each time we make an update, we are moving the sequence toward states that is more representative under <span class="math inline">\(\pi\)</span>. If we run this process for long enough, the first arbitrary choice <span class="math inline">\(\omega_0\)</span> gets drowned out. Eventually, the configurations the algorithm visits become more and more like they are samples drawn from the true distribution <span class="math inline">\(\pi\)</span>.</p>
<p>It turns out that <span class="math inline">\(\omega_t\)</span> defined in this way is a Markov Chain. If you are unfamiliar with Markov Chains, I highly suggest you read my previous blog <a href="https://csuraparaju.github.io/posts/markov-chains/">post</a> on them. Be warned: the rest of this posts assumes you are familiar with the big ideas/theorems from that post!</p>
</section>
<section id="the-metropolis-hastings-algorithm" class="level2">
<h2 class="anchored" data-anchor-id="the-metropolis-hastings-algorithm">The Metropolis-Hastings Algorithm</h2>
<p>Note: From here on, I’ll remove the dependence on <span class="math inline">\(s\)</span> for notational clarity, writing <span class="math inline">\(\pi(\omega)\)</span> instead of <span class="math inline">\(\pi(\omega | s)\)</span>.</p>
<p>Notice that the process discussed at the end of the previous section can be thought of as a Markov Chain. We start out with some initial configuration <span class="math inline">\(\omega_0\)</span>, and for each time step decide if we need to resample an <span class="math inline">\(\omega_1\)</span> or not. If we keep running this process, we’ll have a Markov Chain <span class="math inline">\(\omega_t\)</span>. I’ll leave it as an exercise for you to prove that this process indeed does have the Markov Property.</p>
<p>To turn this self-correcting sequence idea into an algorithm, we need to formalize how we pick a new candidate and how we decide to accept it.</p>
<p>First, we need a way to pick a candidate <span class="math inline">\(\omega'\)</span> given our current state <span class="math inline">\(\omega_t\)</span>. We call this the proposal distribution, denoted <span class="math inline">\(Q(\omega' | \omega_t)\)</span>. In the case of our protein lattice, a proposal might be as simple as picking one residue at random and try to move it to an adjacent empty spot. This is just a mechanism to explore the space; <span class="math inline">\(Q\)</span> doesn’t need to know anything about the <span class="math inline">\(HH\)</span> contacts or the true distribution <span class="math inline">\(\pi\)</span>.</p>
<p>Once we have our candidate <span class="math inline">\(\omega'\)</span>, we need an exact rule for the filter. We want this rule to guarantee that the stationary distribution of our chain is exactly <span class="math inline">\(\pi\)</span>. This rule is the Acceptance Probability, <span class="math inline">\(\alpha(\omega_t, \omega')\)</span>. It tells us the exact probability with which we should move to the new state. If we don’t move, we simply stay at <span class="math inline">\(\omega_t\)</span> for another time step.</p>
<p>Combining the ideas gives us the Metropolis-Hastings algorithm</p>
<div class="algorithm">
<p><strong>Metropolis-Hastings Algorithm</strong></p>
<p><span class="math inline">\(\omega_0 \gets\)</span> initial configuration</p>
<p>for <span class="math inline">\(t = 0\)</span> to <span class="math inline">\(T-1\)</span>:</p>
<p><span class="math inline">\(\quad\)</span> Propose a new configuration <span class="math inline">\(\omega'\)</span> with probability <span class="math inline">\(Q(\omega_t, \omega')\)</span></p>
<p><span class="math inline">\(\quad\)</span> Define the Acceptance Probability <span class="math inline">\(A(\omega_t, \omega')\)</span> by:</p>
<p><span class="math display">\[
A(\omega_t, \omega') := \min\left\{1, \frac{\pi_u(\omega')Q(\omega', \omega_t)}{\pi_u(\omega_t)Q(\omega_t, \omega')}\right\}
\]</span> <span class="math inline">\(\quad\)</span> Choose <span class="math inline">\(U_{t + 1} \sim \text{Unif}([0, 1])\)</span> independently and update</p>
<p><span class="math display">\[
\omega_{t + 1} = \begin{cases}
\omega' &amp;&amp; \text{if } U_{t+1} \leq A \\
\omega_t &amp;&amp; \text{otherwise}\\
\end{cases}
\]</span></p>
<p>Note: <span class="math inline">\(T\)</span> should be chosen large enough for the chain to reach its stationary distribution.</p>
</div>
<p>This algorithm is a more formal version of the intuition we’ve developed so far. It defines a new Markov Chain <span class="math inline">\(\omega_t\)</span> (called the MH chain) and simulates this chain for a very long time.</p>
<p>But is this method actually correct? That is, will our sequence <span class="math inline">\(\omega_0, \omega_1, \cdots, \omega_t, \omega_{t + 1}, \cdots\)</span> eventually look like it resembles <span class="math inline">\(\pi\)</span> if we follow this algorithm? Well, we have a nice theorem (discussed in this <a href="https://csuraparaju.github.io/posts/markov-chains/">post</a>) that says irreducible and aperiodic Markov chains converge to their stationary distribution, no matter the starting distribution. So, if we can show that <span class="math inline">\(\pi\)</span> is a stationary distribution of <span class="math inline">\(\omega_t\)</span>, and <span class="math inline">\(\omega_t\)</span> is irreducible and aperiodic, then we can apply the theorem to conclude that <span class="math display">\[
\lim_{t \to \infty} \mathbb{P}[\omega_t = \omega] = \pi(\omega)
\]</span></p>
<p>The hard part in this is showing that <span class="math inline">\(\pi\)</span> is indeed a stationary distribution of <span class="math inline">\(\omega_t\)</span>. There are some useful propositions we should prove first, to help us establish this result.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Proposition 1
</div>
</div>
<div class="callout-body-container callout-body">
<p>If <span class="math inline">\(\mu\)</span> is a distribution and <span class="math inline">\(P\)</span> is the transition matrix of a Markov Chain such that <span class="math display">\[
\mu(x) P(x, y) = \mu(y) P(y, x)
\]</span> for every <span class="math inline">\(x, y \in \chi\)</span>, then <span class="math inline">\(\mu\)</span> must be a stationary distribution of <span class="math inline">\(P\)</span>.</p>
</div>
</div>
<p><em>Proof</em>:</p>
<p>Note that we have <span class="math display">\[\begin{align*}
(\mu P) (y) &amp;= \sum_{x \in \chi}\mu(x) P(x, y) \\
&amp;= \sum_{x \in \chi} \mu(y) P(y, x) \tag{By assumption}\\
&amp;= \mu(y)\sum_{x \in \chi} P(y, x) \\
&amp;= \mu(y) \tag{Since rows of $P$ sum to 1}
\end{align*}\]</span> Therefore, <span class="math inline">\(\mu\)</span> is a stationary distribution.</p>
<p>Now, we can prove our correctness theorem:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Theorem
</div>
</div>
<div class="callout-body-container callout-body">
<p>The MH Markov Chain <span class="math inline">\(\omega_t\)</span> as defined above has <span class="math inline">\(\pi\)</span> as a stationary distribution.</p>
</div>
</div>
<p><em>Proof</em>:</p>
<p>Note: Since ratios <span class="math inline">\(\pi(\omega') / \pi(\omega)\)</span> equal <span class="math inline">\(\pi_u(\omega')/ \pi_u(\omega)\)</span>, the acceptance probabilities computed with <span class="math inline">\(\pi_u\)</span> in the algorithm is equivalent to those computed with <span class="math inline">\(\pi\)</span>. Therefore, we can write the proof using <span class="math inline">\(\pi\)</span> without loss of generality</p>
<p>First we need to identify the transition matrix of the Markov Chain <span class="math inline">\(\omega_t\)</span>. Observe that for any two configurations <span class="math inline">\(\omega\)</span> and <span class="math inline">\(\omega'\)</span>, if <span class="math inline">\(\omega \neq \omega'\)</span>, then the probability that <span class="math inline">\(\omega_t\)</span> transitions from <span class="math inline">\(\omega\)</span> to <span class="math inline">\(\omega'\)</span> is <span class="math inline">\(Q(\omega, \omega')A(\omega, \omega')\)</span> since we propose <span class="math inline">\(\omega'\)</span> independently and accept <span class="math inline">\(\omega'\)</span> independently. Now, if <span class="math inline">\(\omega = \omega'\)</span>, then the probability that <span class="math inline">\(\omega_t\)</span> transitions from <span class="math inline">\(\omega\)</span> to <span class="math inline">\(\omega'\)</span> is same as the probability that we do not make a transition at all. This is <span class="math display">\[
1 - \sum_{\omega'' \neq \omega} Q(\omega, \omega'') A(\omega, \omega'')
\]</span> Therefore, the transition matrix of the MH chain is given by <span class="math display">\[
P(\omega, \omega') = \begin{cases}
Q(\omega, \omega') A(\omega, \omega') &amp;&amp; \text{if } \omega \neq \omega' \\
1 - \sum_{\omega'' \neq \omega} Q(\omega, \omega'') A(\omega, \omega'') &amp;&amp; \text{if } \omega = \omega'
\end{cases}
\]</span></p>
<p>Now, if <span class="math inline">\(\omega = \omega'\)</span> then we trivially have the condition <span class="math display">\[\begin{align*}
\pi(\omega) P(\omega, \omega') &amp;= \pi(\omega') P(\omega', \omega)
\end{align*}\]</span></p>
<p>Therefore, by proposition <span class="math inline">\(1\)</span>, we can conclude that <span class="math inline">\(\pi\)</span> is a stationary distribution of <span class="math inline">\(P\)</span> in this case. Now, assume that <span class="math inline">\(\omega \neq \omega'\)</span>, and WLOG (by symmetry) that</p>
<p><span class="math display">\[\begin{align*}
\pi(\omega) Q(\omega, \omega') &amp;\leq \pi(\omega') Q(\omega', \omega) \\
1 &amp;\leq \frac{\pi(\omega') Q(\omega', \omega)}{\pi(\omega) Q(\omega, \omega')} \tag{All terms are non-negative}
\end{align*}\]</span></p>
<p>This must imply that in this case, <span class="math display">\[\begin{align*}
A(\omega, \omega') &amp;= \min\left\{1, \frac{\pi(\omega') Q(\omega', \omega)}{\pi(\omega) Q(\omega, \omega')}\right\} = 1
\end{align*}\]</span></p>
<p>Additionally, we must have <span class="math display">\[
\begin{align*}
A(\omega', \omega) &amp;= \min\left\{1, \frac{\pi(\omega) Q(\omega, \omega')}{\pi(\omega') Q(\omega', \omega)}\right\} = \frac{\pi(\omega) Q(\omega, \omega')}{\pi(\omega') Q(\omega', \omega)}
\end{align*}
\]</span> Now, we can put everything together and conclude that <span class="math display">\[
\begin{align*}
\pi(\omega)P(\omega,\omega') &amp;= \pi(\omega)[Q(\omega,\omega')\underbrace{A(\omega,\omega')}_{=1} ] \\
&amp;= \pi(\omega) Q(\omega,\omega')  \\
\end{align*}
\]</span></p>
<p>But we can also write:</p>
<p><span class="math display">\[
\begin{align*}
\pi(\omega')P(\omega',\omega) &amp;= \pi(\omega') Q(\omega',\omega)A(\omega',\omega) \\
&amp;= \pi(\omega') Q(\omega', \omega) \left[\frac{\pi(\omega) Q(\omega, \omega')}{\pi(\omega') Q(\omega', \omega)}\right] \\
&amp;= \pi(\omega) Q(\omega, \omega')
\end{align*}
\]</span> Therefore, we have that <span class="math display">\[
\pi(\omega)P(\omega,\omega') = \pi(\omega')P(\omega',\omega)
\]</span></p>
<p>and so using proposition <span class="math inline">\(1\)</span>, we can conclude that <span class="math inline">\(\pi\)</span> is in-fact a stationary distribution of <span class="math inline">\(P\)</span>. The other case is symmetric, and so this completes the proof.</p>
<p>Now, all that remains to prove correctness and gain apply the limiting theorem of Markov Chains and stationary distribution is to show that the MH chain is irreducible and aperiodic.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Proposition 2
</div>
</div>
<div class="callout-body-container callout-body">
<p>If the proposal distribution <span class="math inline">\(Q\)</span> satisfies <span class="math inline">\(Q(\omega, \omega') &gt; 0\)</span> for all <span class="math inline">\(\omega, \omega' \in \chi\)</span>, then the MH chain is irreducible and aperiodic.</p>
</div>
</div>
<p><em>Proof</em>:</p>
<p><strong>Irreducibility</strong>: We need to show that for any two configurations <span class="math inline">\(\omega\)</span> and <span class="math inline">\(\omega'\)</span>, there exists some <span class="math inline">\(t\)</span> such that <span class="math inline">\(P^t(\omega, \omega') &gt; 0\)</span>, meaning we can reach <span class="math inline">\(\omega'\)</span> from <span class="math inline">\(\omega\)</span> in finitely many steps.</p>
<p>Since <span class="math inline">\(Q(\omega, \omega') &gt; 0\)</span> by assumption, we can propose <span class="math inline">\(\omega'\)</span> from <span class="math inline">\(\omega\)</span> with positive probability. The acceptance probability satisfies <span class="math inline">\(A(\omega, \omega') &gt; 0\)</span> whenever <span class="math inline">\(Q(\omega, \omega') &gt; 0\)</span> since we’ve shown in the previous post that <span class="math inline">\(\pi &gt; 0\)</span> and we assumed that <span class="math inline">\(Q &gt; 0\)</span>. Therefore, <span class="math display">\[
P(\omega, \omega') = Q(\omega, \omega') A(\omega, \omega') &gt; 0
\]</span> This means we can reach any state from any other state in one step, making the chain irreducible.</p>
<p><strong>Aperiodicity</strong>: Recall that a chain is aperiodic if for some state <span class="math inline">\(\omega\)</span>, we have <span class="math inline">\(\gcd\{t : P^t(\omega, \omega) &gt; 0\} = 1\)</span>.</p>
<p>Notice that there is always a positive probability of rejecting the proposed state and staying at <span class="math inline">\(\omega\)</span>. Specifically, the probability of staying at <span class="math inline">\(\omega\)</span> is at least the probability of proposing some <span class="math inline">\(\omega'\)</span> and then rejecting it. Since there always exists some <span class="math inline">\(\omega'\)</span> such that <span class="math inline">\(A(\omega, \omega') &lt; 1\)</span>, we have <span class="math display">\[
P(\omega, \omega) \geq Q(\omega, \omega') (1 - A(\omega, \omega')) &gt; 0
\]</span> for some <span class="math inline">\(\omega'\)</span>. This means we can return to <span class="math inline">\(\omega\)</span> in one step with positive probability, which immediately implies the chain is aperiodic (since <span class="math inline">\(\gcd\)</span> of any set containing <span class="math inline">\(1\)</span> is <span class="math inline">\(1\)</span>).</p>
<p>Combining our results, we get a powerful convergence theorem:</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Convergence Theorem
</div>
</div>
<div class="callout-body-container callout-body">
<p>If <span class="math inline">\(Q(\omega, \omega') &gt; 0\)</span> for all <span class="math inline">\(\omega, \omega'\)</span>, then the MH chain is irreducible and aperiodic with unique stationary distribution <span class="math inline">\(\pi\)</span>. Therefore, for any starting distribution <span class="math inline">\(\omega_0\)</span>, we have <span class="math display">\[
\lim_{t \to \infty} \mathbb{P}[\omega_t = \omega] = \pi(\omega)
\]</span> In other words, the distribution of <span class="math inline">\(\omega_t\)</span> converges to <span class="math inline">\(\pi\)</span> regardless of where we start!</p>
</div>
</div>
<p>This is the key result that makes the Metropolis-Hastings algorithm work: if we run the chain long enough, the samples we generate will be approximately distributed according to <span class="math inline">\(\pi\)</span>, even though we never computed the normalizing constant <span class="math inline">\(Z\)</span>.</p>
</section>
<section id="back-to-protein-folding" class="level2">
<h2 class="anchored" data-anchor-id="back-to-protein-folding">Back to Protein Folding</h2>
<p>Now that we’ve established the theoretical guarantees of the Metropolis-Hastings algorithm, let’s return to the HP model for protein folding. We’ve shown that MH can sample from <span class="math inline">\(\pi(\omega)\)</span> without computing the normalizing constant <span class="math inline">\(Z\)</span>, but we still need to solve an important problem: what should our proposal chain <span class="math inline">\(Q\)</span> be?</p>
<p>Recall that we need <span class="math inline">\(Q(\omega, \omega') &gt; 0\)</span> for all configurations <span class="math inline">\(\omega, \omega'\)</span> to guarantee convergence. In theory, convergence happens eventually, however in practice convergence may happen very slowly, and we might have to wait for a very long time before the distribution of <span class="math inline">\(\omega_t\)</span> is close enough to <span class="math inline">\(\pi\)</span>. Therefore, we need to choose the proposal mechanism <span class="math inline">\(Q\)</span> in a way that improves the rate of convergence to the stationary distribution. However, coming up with these mechanisms is usually problem specific, and estimating the rate of convergence for a given proposal mechanism is not easy. In general, a good proposal distribution should satisfy the following requirements:</p>
<ol type="1">
<li>We want to propose moves that are likely to be accepted, so we don’t waste time rejecting proposals</li>
<li>We want to explore the configuration space efficiently, not just make tiny local changes</li>
<li>We need to be able to reach any configuration from any other configuration through a finite sequence of moves</li>
</ol>
<p>For the HP model, we will use a proposal mechanism initially developed by Madras and Sokal called pivot moves when working on problems in statistical physics. Refer to this <a href="https://link.springer.com/article/10.1007/BF01022990">paper</a> for more details. What is important for us to know is that the pivot move set is complete (so any configuration can be transformed into any other configuration) and very fast at changing the global shape of the protein. The con is that for a very dense protein, the acceptance rate is low because rotating a large tail usually causes a collision.</p>
<section id="pivot-moves" class="level3">
<h3 class="anchored" data-anchor-id="pivot-moves">Pivot Moves</h3>
<p>The intuition behind a pivot move is that we treat a portion of the protein as fixed and swing the other end around a pivot.</p>
<p>Imagine the protein chain laid out on the lattice. You pick a random residue <span class="math inline">\(i\)</span> to be your pivot point. You keep the segment from <span class="math inline">\(1\)</span> to <span class="math inline">\(i\)</span> fixed in place. Then, you take the residues from <span class="math inline">\(i+1\)</span> to <span class="math inline">\(N\)</span> and apply a symmetrical transformation of the square lattice such as a <span class="math inline">\(90^\circ\)</span> rotation or a reflection using the pivot point as the origin.</p>
<p>More formally, a pivot move <span class="math inline">\(\omega \to \omega'\)</span> can be described as:</p>
<ol type="1">
<li>Choose <span class="math inline">\(i \in \{1, \dots, N\}\)</span> uniformly at random.</li>
<li>Choose an element <span class="math inline">\(g\)</span> from the symmetry group of the square lattice, which is the Dihedral group <span class="math inline">\(D_4\)</span>. These symmetries include rotations by <span class="math inline">\(90^\circ, 180^\circ, 270^\circ\)</span> and four axes of reflection.</li>
<li>For all <span class="math inline">\(k &gt; i\)</span>, the new position <span class="math inline">\(\omega'(k)\)</span> is updated as <span class="math display">\[\omega'(k) = g(\omega(k) - \omega(i)) + \omega(i)\]</span></li>
</ol>
<p>Below is a visualization of a pivot move. It depicts a pivot move for the amino acid at index <span class="math inline">\(i = 3\)</span> with a 90 degree clockwise rotation. Notice how only residues <span class="math inline">\(3\)</span> and <span class="math inline">\(4\)</span> changed positions.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="pivot_moves.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="pivot_moves.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
</section>
<section id="metropolis-hastings-for-hp-model" class="level3">
<h3 class="anchored" data-anchor-id="metropolis-hastings-for-hp-model">Metropolis-Hastings for HP Model</h3>
<p>With our proposal distribution defined, the Metropolis-Hastings algorithm for the HP model becomes:</p>
<ol type="1">
<li>Start with an initial valid configuration <span class="math inline">\(\omega_0\)</span> (e.g., a straight chain)</li>
<li>At each iteration <span class="math inline">\(t\)</span>:
<ul>
<li>Propose a new configuration <span class="math inline">\(\omega'\)</span> by performing a pivot move on <span class="math inline">\(\omega_t\)</span></li>
<li>Compute the energy difference <span class="math inline">\(\Delta E = E(s, \omega') - E(s, \omega_t)\)</span></li>
<li>Calculate the acceptance probability: <span class="math display">\[A(\omega_t, \omega') = \min\left\{1, \frac{e^{-E(s, \omega')/k_B T} \cdot Q(\omega', \omega_t)}{e^{-E(s, \omega_t)/k_B T} \cdot Q(\omega_t, \omega')} \right\} = \min\{1, e^{-\Delta E / k_B T} \cdot R\}\]</span> where <span class="math inline">\(R = Q(\omega', \omega_t) / Q(\omega_t, \omega')\)</span></li>
<li>Accept or reject based on <span class="math inline">\(A(\omega_t, \omega')\)</span></li>
</ul></li>
<li>Run for <span class="math inline">\(T\)</span> iterations until convergence</li>
</ol>
<p>Notice how the energy calculation simplifies. We only need to count the <span class="math inline">\(HH\)</span> contacts in <span class="math inline">\(\omega'\)</span> and <span class="math inline">\(\omega_t\)</span>, which is much faster than computing the full partition function <span class="math inline">\(Z\)</span>. We can write an implementation in python for running this algorithm and visualize how our <span class="math inline">\(\omega_t\)</span> changes over time for a specific amino acid string. Full disclosure: I’ve generated the following animation by giving Anthropic’s Claude model this algorithm and asking it to write a simulation for the sequence <span class="math inline">\(s = HPPHPPHHPPHHPPHH\)</span>. Click on the play button below to see how the configurations evolve over time.</p>
<div class="quarto-video"><video id="video_shortcode_videojs_video1" width="800" height="600" class="video-js vjs-default-skin " controls="" preload="auto" data-setup="{}" title="My Animation"><source src="protein_folding.webm"></video></div>
<p>This should line up with our theoretical result. Recall that our probability distribution <span class="math inline">\(\pi(\omega) \propto e^{-E(\omega)}\)</span>. This function looks something like</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="e_minus_x.png" class="lightbox" data-gallery="quarto-lightbox-gallery-4"><img src="e_minus_x.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:70.0%"></a></p>
</figure>
</div>
<p>up to different scales and translations. Therefore, the configurations that are most likely under <span class="math inline">\(\pi\)</span> are ones that minimize the energy function <span class="math inline">\(E\)</span>. Since we defined <span class="math inline">\(E\)</span> to only count <span class="math inline">\(HH\)</span> contacts, the configuration that minimizes energy are the ones with the most <span class="math inline">\(HH\)</span> contacts. This is exactly what we see in the video above! As <span class="math inline">\(t\)</span> grows, we see that we sample configurations which have more and more <span class="math inline">\(HH\)</span> contacts. Remember the diagram at the beginning showing how hydrophobic residues cluster together on the inside while polar residues remain on the outside? Now we know exactly why this happens.</p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The main benefit of this approach is its generality. Whether we’re studying protein folding, sampling from complex Bayesian posteriors, or exploring other high-dimensional probability distributions, the same algorithm can be used. The theoretical guarantees from Markov Chains tells us that given enough time, our samples will be representatives of the true distribution <span class="math inline">\(\pi\)</span>.</p>
<p>Of course, there are practical challenges we didn’t fully address. How many iterations <span class="math inline">\(T\)</span> do we need before convergence? How do we detect convergence? Can we do better than pivot moves for protein folding? These are active areas of research in computational statistics and biophysics. Variants like Hamiltonian Monte Carlo, Gibbs sampling, and replica exchange methods build on the MH framework to improve convergence rates for specific problem classes. Check out those approaches if this was interesting to you!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/csuraparaju\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<script>videojs(video_shortcode_videojs_video1);</script>
<script>var lightboxQuarto = GLightbox({"closeEffect":"zoom","descPosition":"bottom","loop":false,"openEffect":"zoom","selector":".lightbox"});
(function() {
  let previousOnload = window.onload;
  window.onload = () => {
    if (previousOnload) {
      previousOnload();
    }
    lightboxQuarto.on('slide_before_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      const href = trigger.getAttribute('href');
      if (href !== null) {
        const imgEl = window.document.querySelector(`a[href="${href}"] img`);
        if (imgEl !== null) {
          const srcAttr = imgEl.getAttribute("src");
          if (srcAttr && srcAttr.startsWith("data:")) {
            slideConfig.href = srcAttr;
          }
        }
      } 
    });
  
    lightboxQuarto.on('slide_after_load', (data) => {
      const { slideIndex, slideNode, slideConfig, player, trigger } = data;
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(slideNode);
      }
    });
  
  };
  
})();
          </script>




</body></html>