<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Krish Suraparaju">
<meta name="dcterms.date" content="2025-10-08">

<title>Algorithms for Sampling from a probability distribution – Krish’s blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-5b4ad623e5705c0698d39aec6f10cf02.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Krish’s blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Krish Suraparaju</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/csuraparaju"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/krish-suraparaju/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Algorithms for Sampling from a probability distribution</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">math</div>
                <div class="quarto-category">cs</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Krish Suraparaju </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 8, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Drawing samples from a probability distribution <span class="math inline">\(\pi\)</span> is a problem that arises often in computer science. For example in generative AI, language models sample tokens from learned probability distributions to generate new text. In computer graphics, many graphical engines randomly sample light paths bouncing around to simulate realistic lighting. But what exactly does it mean for a computer or an algorithm to sample from a probability distribution? How can a deterministic machine like a modern computer sample “randomly” from a distribution?</p>
</section>
<section id="hardware-assumptions" class="level2">
<h2 class="anchored" data-anchor-id="hardware-assumptions">Hardware Assumptions</h2>
<p>On most modern computers, one bit represents an atom of data or computation. So, if we want our computer to generate random samples, we would probably need it to be able to generate uniformly random bits. Let’s assume we have a black box machine that does exactly that.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Above assumption is not an unrealistic one since we have <a href="https://en.wikipedia.org/wiki/Hardware_random_number_generator">hardware random bit generators</a> which generate random bits from physical process that produce entropy.</p>
</div>
</div>
</div>
<p>More formally, let <span class="math inline">\(B \in \{0, 1\}\)</span> be a uniform random bit with <span class="math display">\[\mathbb{P}[B = 0] = \mathbb{P}[B = 1] = \frac{1}{2}\]</span> and assume that we can sample from <span class="math inline">\(B\)</span>.</p>
</section>
<section id="the-uniform-distribution" class="level2">
<h2 class="anchored" data-anchor-id="the-uniform-distribution">The Uniform Distribution</h2>
<p>Let’s start the discussion by coming up with algorithms for sampling integers uniformly randomly in a fixed range.</p>
<section id="integer-in-range-0-2n" class="level3">
<h3 class="anchored" data-anchor-id="integer-in-range-0-2n">Integer in range <span class="math inline">\([0, 2^N]\)</span></h3>
<p>First, let’s see if we can generate a uniformly random integer <span class="math inline">\(M \in \{0, \cdots, 2^N - 1\}\)</span>. That is, we want to come up with an algorithm to produce <span class="math inline">\(M\)</span> such that <span class="math display">\[\mathbb{P}[M = m] = \frac{1}{2^N}\]</span> for all <span class="math inline">\(m \in \{0, \cdots, 2^N - 1\}\)</span>.</p>
<p>Well, given that we only have a random bit generator, there is really only one thing we can do here. We should generate <span class="math inline">\(N\)</span> independent bits using our random bit generator and concatenate them together to get the base 2 representation of the integer we return.</p>
<div class="algorithm">
<p><strong>Algorithm 1</strong></p>
<p><span class="math inline">\(M \gets 0\)</span></p>
<p>for <span class="math inline">\(i = 1\)</span> to <span class="math inline">\(N\)</span> do</p>
<p><span class="math inline">\(\quad M \gets M + B_i \cdot 2^i\)</span></p>
<p>return <span class="math inline">\(M\)</span></p>
</div>
<p>Let’s check that this gives us the desired result. Let <span class="math inline">\(B_1, B_2, \dots, B_N\)</span> be the bits we generated. Now, note that for any integer <span class="math inline">\(k \in \{0, \cdots, 2^N - 1\}\)</span>, there exists a unique binary representation: <span class="math display">\[
k = \sum_{i = 1}^{N} b_i \cdot 2^i
\]</span> where each <span class="math inline">\(b_i \in \{0, 1\}\)</span> is the <span class="math inline">\(i\)</span>-th bit of <span class="math inline">\(k\)</span>. The probability that <span class="math inline">\(M = k\)</span> is given as: <span class="math display">\[\begin{align*}
\mathbb{P}[M = k] &amp;= \mathbb{P}[B_0 = b_0, B_1 = b_1, \cdots, B_n = b_n] \\
&amp;= \mathbb{P}[B_0 = b_0] \cdot \mathbb{P}[B_1 = b_1] \cdots \mathbb{P}[B_N = b_n] \tag{By independence} \\
&amp;= \frac{1}{2} \cdot \frac{1}{2} \cdots \frac{1}{2} \tag{$N$ times} \\
&amp;= \frac{1}{2^N}
\end{align*}\]</span> as desired.</p>
</section>
<section id="integer-in-arbitrary-range" class="level3">
<h3 class="anchored" data-anchor-id="integer-in-arbitrary-range">Integer in Arbitrary Range</h3>
<p>Great, now lets move onto a slightly more difficult problem: generating a uniformly random integer in <span class="math inline">\(\{0, \dots, M\}\)</span>, where <span class="math inline">\(M\)</span> is not necessarily a power of <span class="math inline">\(2\)</span>.</p>
<p>A first idea would be to use the same approach as before and concatenate a string of <span class="math inline">\(N\)</span> random bits. This, however, does not work. For example, if <span class="math inline">\(N = 3\)</span> and <span class="math inline">\(M = 4\)</span> then our random bit generator produces outcomes in the range <span class="math inline">\(\{0, \dots, 2^3 - 1\} = \{0, 1, 2, 3, 4, 5, 6, 7\}\)</span>. Each of these <span class="math inline">\(8\)</span> outcomes occurs with probability <span class="math inline">\(\frac{1}{8}\)</span>. However, we wanted an integer in the range <span class="math inline">\(\{0, 1, 2, 3, 4\}\)</span>, and the probability of each outcome to be exactly <span class="math inline">\(\frac{1}{5}\)</span>.</p>
<p>Another approach would be to generate <span class="math inline">\(N\)</span> random bits as before, and then return <span class="math inline">\(N \mod (M + 1)\)</span>. I leave it as an exercise to figure out why this approach also does not work (Hint: use the same counter example from above).</p>
<p>Notice that the issue in the above two approach is that our algorithm considers values that are outside the given range. To fix this problem, one idea would be to simply ignore an integers that are outside the range. More formally, define the algorithm as</p>
<div class="algorithm">
<p><strong>Algorithm 2</strong></p>
<p><span class="math inline">\(P \gets \lceil \log_2 (M + 1) \rceil\)</span></p>
<p>repeat</p>
<p><span class="math inline">\(\quad\)</span> Generate <span class="math inline">\(N \in \{0, \cdots, 2^P - 1\}\)</span> using Algorithm 1</p>
<p>until <span class="math inline">\(N \leq M\)</span></p>
<p>return <span class="math inline">\(N\)</span></p>
</div>
<p>This algorithm is called rejection sampling. A subtle difference between this algorithm and the previous algorithm is that its running time is non-deterministic. For example, we know that algorithm 1 terminates after generating <span class="math inline">\(N\)</span> random bits. Algorithm 2, however, has no such guarantees. It is technically possible that we get really really really unlucky and always generate <span class="math inline">\(N &gt; M\)</span> and so the algorithm would never return a number.</p>
<p>So, let’s compute probability that the algorithm terminates, which only happens when <span class="math inline">\(N \leq M\)</span> <span class="math display">\[\begin{align*}
\mathbb{P}[N \leq M] &amp;= \sum_{i \leq M} \mathbb{P}[N = i] \tag{CDF of $N$} \\
&amp;= \sum_{i = 0}^M \frac{1}{2^N} \tag{From Algorithm 1} \\
&amp;= \frac{(M + 1)}{2^N}
\end{align*}\]</span></p>
<p>Note that if <span class="math inline">\(M \ll N\)</span> then the exponential in the denominator dominates, and the probability of terminating is near zero. When <span class="math inline">\(M \gg N\)</span> then the fraction is approximately linear, and so the algorithm terminates with higher probability.</p>
<p>However, in the case that the algorithm does return, then we can be sure that it is correct. We prove this below. Note that for any <span class="math inline">\(k \in \{0, \cdots, M\}\)</span>, we have <span class="math display">\[\begin{align*}
\mathbb{P}[N = k] &amp;= \mathbb{P}[N = k | N \leq M] \tag{Since $N \leq M$ iff $N$ is returned} \\
&amp;= \frac{\mathbb{P}[N = k, N \leq M]}{\mathbb{P}[N \leq M]} \tag{Definition of conditional prob.} \\
&amp;= \frac{\mathbb{P}[N = k]}{\mathbb{P}[N \leq M]} \tag{$k \leq M$ so if $N = k$, we know $N \leq M$} \\
&amp;= \frac{1/2^N}{(M+1)/2^N} \\
&amp;= \frac{1}{M + 1}
\end{align*}\]</span> as desired.</p>
</section>
<section id="real-number-in-range-0-1" class="level3">
<h3 class="anchored" data-anchor-id="real-number-in-range-0-1">Real number in range <span class="math inline">\([0, 1]\)</span></h3>
<p>Now let’s move onto the hardest problem yet: sampling a real number in the range <span class="math inline">\([0, 1]\)</span>. Note that every real number <span class="math inline">\(r \in [0, 1]\)</span> can be represented as a binary expansion: <span class="math display">\[
r = \sum_{i=1}^{\infty} \frac{B_i}{2^i} = 0.B_1B_2B_3\dots
\]</span> where each <span class="math inline">\(B_i \in \{0, 1\}\)</span>. Again, our first instinct should be to ask if generating an infinite string of bits and concatenating them gives us the desired result. In this case, it turns out to be true. However, the proof of this fact is non-trivial and takes quite a lot of work.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Important</span>Main Claim
</div>
</div>
<div class="callout-body-container callout-body">
<p>If <span class="math inline">\(B_1, B_2, B_3, \dots\)</span> are independent uniform random bits, then <span class="math display">\[
U = \sum_{i=1}^{\infty} \frac{B_i}{2^i}
\]</span> is uniformly distributed on <span class="math inline">\([0, 1]\)</span>.</p>
</div>
</div>
<p>To prove this, we need to show that for any interval <span class="math inline">\([a, b) \subseteq [0, 1]\)</span>, we have <span class="math display">\[
\mathbb{P}[U \in [a, b)] = \text{length}([a, b)]) = b - a
\]</span></p>
<section id="partitioning-0-1-and-characterizing-the-partitions" class="level4">
<h4 class="anchored" data-anchor-id="partitioning-0-1-and-characterizing-the-partitions">Partitioning <span class="math inline">\([0, 1]\)</span> and characterizing the partitions</h4>
<p>The proof uses a clever partitioning argument. We’ll divide <span class="math inline">\([0, 1]\)</span> into dyadic intervals, which are defined to be intervals whose endpoints are fractions with powers of 2 in the denominator.</p>
<p>For any arbitrary <span class="math inline">\(k \in \mathbb{N}\)</span>, we can partition <span class="math inline">\([0, 1]\)</span> into <span class="math inline">\(2^k\)</span> equal intervals: <span class="math display">\[
I_j = \left[\frac{j}{2^k}, \frac{j+1}{2^k}\right) \quad \text{for } j = 0, 1, \dots, 2^k - 1
\]</span></p>
<p>Each interval has length <span class="math inline">\(\frac{1}{2^k}\)</span>, and together they cover the entire unit interval. The larger <span class="math inline">\(k\)</span>, the better this approximation gets.</p>
<p>Now, I claim that the first <span class="math inline">\(k\)</span> bits <span class="math inline">\((B_1, \dots, B_k)\)</span> of <span class="math inline">\(U\)</span> completely determine which dyadic interval <span class="math inline">\(I_j\)</span> contains the value <span class="math inline">\(U\)</span>. Specifically: <span class="math display">\[
U \in I_j = \left[\frac{j}{2^k}, \frac{j+1}{2^k}\right) \iff \sum_{i=1}^{k} \frac{B_i}{2^{i}} = \frac{j}{2^k}
\]</span></p>
<p>To see why, we can decompose <span class="math inline">\(U\)</span> into two parts:</p>
<p><span class="math display">\[
U = \underbrace{\sum_{i=1}^{k} \frac{B_i}{2^i}}_{:=U_k} + \underbrace{\sum_{i=k+1}^{\infty}\frac{B_i}{2^i}}_{:=R_k}
\]</span> where <span class="math inline">\(U_k\)</span> represents the first <span class="math inline">\(k\)</span> bits and <span class="math inline">\(R_k\)</span> represents the remaining bits. Now, note that The first <span class="math inline">\(k\)</span> bits can only produce discrete values because there are <span class="math inline">\(2^k\)</span> possible bit strings of length <span class="math inline">\(k\)</span>, and these values are <span class="math display">\[\left\{0, \frac{1}{2^k}, \frac{2}{2^k}, \ldots, \frac{2^k-1}{2^k}\right\}\]</span> Observe that these are exactly the left endpoints of our dyadic intervals <span class="math inline">\(I_j\)</span>.</p>
<p>Now, The remaining bits <span class="math inline">\(R_k\)</span> can be rewritten by factoring out <span class="math inline">\(\frac{1}{2^k}\)</span>: <span class="math display">\[\begin{align*}
R_k &amp;= \sum_{i=k+1}^{\infty} \frac{B_i}{2^i} = \frac{1}{2^k} \sum_{i=1}^{\infty} \frac{B_{k+i}}{2^i}
\end{align*}\]</span> Since <span class="math inline">\(\sum_{i=1}^{\infty} \frac{B_{k+i}}{2^i}\)</span> is a binary expansion taking values in <span class="math inline">\([0, 1)\)</span>, we have <span class="math display">\[0 \leq R_k &lt; \frac{1}{2^k}\]</span> So, we have that <span class="math inline">\(R_k\)</span> is strictly less than the width of a dyadic interval.</p>
<p>Therefore, we can now claim that if <span class="math inline">\(U_k = \frac{j}{2^k}\)</span>, then <span class="math inline">\(U = \frac{j}{2^k} + R_k\)</span> must satisfy <span class="math display">\[\frac{j}{2^k} \leq U &lt; \frac{j+1}{2^k}\]</span> placing <span class="math inline">\(U\)</span> in interval <span class="math inline">\(I_j\)</span>. Conversely, if <span class="math inline">\(U \in I_j\)</span>, the constraint <span class="math display">\[\frac{j}{2^k} \leq U &lt; \frac{j+1}{2^k}\]</span> combined with the fact that <span class="math inline">\(U_k\)</span> is a discrete value in this range forces <span class="math inline">\(U_k = \frac{j}{2^k}\)</span>. Therefore, we have shown that</p>
<div class="callout callout-style-simple callout-tip no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><span class="math display">\[
U \in I_j \iff \sum_{i = 1}^k \frac{B_i}{2^i} = \frac{j}{2^k}
\]</span></p>
</div>
</div>
</div>
</section>
<section id="probability-of-landing-in-i_j" class="level4">
<h4 class="anchored" data-anchor-id="probability-of-landing-in-i_j">Probability of landing in <span class="math inline">\(I_j\)</span></h4>
<p>Now we can calculate the probability that <span class="math inline">\(U\)</span> lands in a specific dyadic interval <span class="math inline">\(I_j\)</span>:</p>
<p><span class="math display">\[\begin{align*}
\mathbb{P}[U \in I_j] &amp;= \mathbb{P}\left[\sum_{i=1}^{k} \frac{B_i}{2^{i}} = \frac{j}{2^k}\right] \\
&amp;= \mathbb{P}[B_1 = b_1, B_2 = b_2, \dots, B_k = b_k]
\end{align*}\]</span></p>
<p>where <span class="math inline">\((b_1, \dots, b_k)\)</span> is the binary representation of <span class="math inline">\(j\)</span>.</p>
<p>Since the bits are independent and each has probability <span class="math inline">\(\frac{1}{2}\)</span>:</p>
<p><span class="math display">\[\begin{align*}
\mathbb{P}[U \in I_j] &amp;= \prod_{i=1}^{k} \mathbb{P}[B_i = b_i] \\
&amp;= \prod_{i=1}^{k} \frac{1}{2} \\
&amp;= \frac{1}{2^k}
\end{align*}\]</span></p>
<p>Note that this is exactly the length of the interval <span class="math inline">\(I_j\)</span>! Therefore, we have show that at least for dyadic intervals, <span class="math inline">\(U\)</span> is uniformly distributed!</p>
</section>
<section id="extending-to-general-intervals" class="level4">
<h4 class="anchored" data-anchor-id="extending-to-general-intervals">Extending to General Intervals</h4>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center collapsed" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Technical Note
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Extending this to the general interval <span class="math inline">\([a, b]\)</span> is complicated and requires careful machinery taught usually in a course in real analysis. Therefore, will handwave a lot of the technicalities, but do keep in mind that there is more careful argument to be made here.</p>
</div>
</div>
</div>
<p>For a general interval <span class="math inline">\([a, b) \subseteq [0, 1]\)</span>, we approximate it using dyadic intervals. Let <span class="math inline">\(J_k\)</span> be the set of indices where <span class="math inline">\(I_j \subseteq [a, b)\)</span>. Then:</p>
<p><span class="math display">\[
[a, b) \approx \bigcup_{j \in J_k} I_j
\]</span></p>
<p>As <span class="math inline">\(k\)</span> increases, the dyadic intervals become finer, and this approximation improves.</p>
<p>Since the dyadic intervals are disjoint:</p>
<p><span class="math display">\[\begin{align*}
\mathbb{P}\left[U \in \bigcup_{j \in J_k} I_j\right] &amp;= \sum_{j \in J_k} \mathbb{P}[U \in I_j] \\
&amp;= \sum_{j \in J_k} \frac{1}{2^k} \\
&amp;= \frac{|J_k|}{2^k}
\end{align*}\]</span></p>
<p>where <span class="math inline">\(|J_k|\)</span> is the number of dyadic intervals that fit inside <span class="math inline">\([a, b)\)</span>.</p>
</section>
<section id="taking-the-limit" class="level4">
<h4 class="anchored" data-anchor-id="taking-the-limit">Taking the Limit</h4>
<p>Notice that <span class="math inline">\(\frac{|J_k|}{2^k}\)</span> represents the total length of all dyadic intervals contained in <span class="math inline">\([a, b)\)</span>:</p>
<p><span class="math display">\[
\frac{|J_k|}{2^k} = \sum_{j \in J_k} \text{length}(I_j)
\]</span></p>
<p>As <span class="math inline">\(k \to \infty\)</span>, these intervals cover <span class="math inline">\([a, b)\)</span> with increasing precision, so we expect</p>
<p><span class="math display">\[
\lim_{k \to \infty} \frac{|J_k|}{2^k} = b - a
\]</span></p>
<p>Therefore:</p>
<p><span class="math display">\[\begin{align*}
\mathbb{P}[U \in [a, b)] &amp;= \lim_{k \to \infty} \mathbb{P}\left[U \in \bigcup_{j \in J_k} I_j\right] \\
&amp;= \lim_{k \to \infty} \frac{|J_k|}{2^k} \\
&amp;= b - a \\
&amp;= \text{length}([a, b))
\end{align*}\]</span></p>
<p>as desired</p>
</section>
<section id="from-theory-to-practice-finite-bit-algorithms" class="level4">
<h4 class="anchored" data-anchor-id="from-theory-to-practice-finite-bit-algorithms">From Theory to Practice: Finite Bit Algorithms</h4>
<p>The theoretical result above is beautiful, but it has a glaring practical issue: we cannot generate an infinite sequence of bits! In the real world, we need to work with a finite number of bits. Fortunately, our proof gives us a natural way to approximate the uniform distribution using only a finite number of bits.</p>
<p>The key insight is that after generating <span class="math inline">\(N\)</span> bits, we’ve already determined which of the <span class="math inline">\(2^N\)</span> dyadic intervals our value falls into. The remaining (ungenerated) bits would only refine our position within that interval, which has width <span class="math inline">\(\frac{1}{2^N}\)</span>. For large <span class="math inline">\(N\)</span>, this interval is so small that the difference is negligible</p>
<p>This leads us to the following algorithm:</p>
<div class="algorithm">
<p><strong>Algorithm 3</strong></p>
<p><span class="math inline">\(U \gets 0\)</span></p>
<p>for <span class="math inline">\(i = 1\)</span> to <span class="math inline">\(N\)</span> do</p>
<p><span class="math inline">\(\quad\)</span> Generate random bit <span class="math inline">\(B_i\)</span></p>
<p><span class="math inline">\(\quad\)</span> <span class="math inline">\(U \gets U + B_i \cdot 2^{-i}\)</span></p>
<p>return <span class="math inline">\(U\)</span></p>
</div>
<p>This algorithm generates values of the form <span class="math inline">\(\frac{k}{2^N}\)</span> where <span class="math inline">\(k \in \{0, 1, \ldots, 2^N - 1\}\)</span>. In other words, it produces a <em>discrete</em> uniform distribution over <span class="math inline">\(2^N\)</span> equally-spaced points in <span class="math inline">\([0, 1]\)</span>, rather than a truly continuous uniform distribution.</p>
<p>Let <span class="math inline">\(U_N\)</span> denote the output of Algorithm 3 and let <span class="math inline">\(U_{\text{true}}\)</span> denote a truly uniform random variable on <span class="math inline">\([0, 1]\)</span>. How far off is our approximation? Well the maximum distance between any generated value and its “true” counterpart is at most the granularity of our discretization: <span class="math display">\[
\max_{x \in [0, 1]} |U_N - x| \leq \frac{1}{2^N}
\]</span> So, if <span class="math inline">\(N = 64\)</span>, then we have: <span class="math display">\[\begin{align*}
\frac{1}{2^{64}} &amp;\approx 5.42 \times 10^{-20} \\
\end{align*}\]</span></p>
<p>This means our approximation error is about <span class="math inline">\(10^{-20}\)</span>! For all practical purposes, this is indistinguishable from a true uniform distribution. In fact, 64-bit floating point numbers (the standard in most programming languages) have a precision of about <span class="math inline">\(10^{-16}\)</span>, which is less precise than our sampling error.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Practical Implementation
</div>
</div>
<div class="callout-body-container callout-body">
<p>In practice, most programming languages use 64-bit floating point numbers for representing real numbers. Algorithm 3 with <span class="math inline">\(N = 64\)</span> bits produces values that are uniformly distributed on the set of representable floating point numbers in <span class="math inline">\([0, 1]\)</span>, which is the best we can do given the finite precision of computer arithmetic.</p>
</div>
</div>
<p>Therefore, Algorithm 3 with <span class="math inline">\(N = 64\)</span> bits gives us an excellent practical algorithm for sampling (approximately) uniform real numbers in <span class="math inline">\([0, 1]\)</span>.</p>
</section>
</section>
</section>
<section id="arbitrary-probability-distribution" class="level2">
<h2 class="anchored" data-anchor-id="arbitrary-probability-distribution">Arbitrary Probability Distribution</h2>
<p>That was a lot of work! If it took so much effort just to sample from the uniform distribution, how can we possibly expect to come up with algorithms for complicated probability distributions? Well, it turns out that with not too much extra work we can sample from any arbitrary distribution <span class="math inline">\(\pi\)</span>. More formally, lets say <span class="math inline">\(\pi\)</span> is a probability distribution on a finite state space <span class="math inline">\(\chi = \{x_1, \cdots x_n\}\)</span>. I want to generate an <span class="math inline">\(X \in \chi\)</span> such that <span class="math display">\[
\mathbb{P}[X = x] = \pi(x)
\]</span> Now that we can sample from the uniform distribution on <span class="math inline">\([0, 1]\)</span>, let’s use that. We will use another clever partitioning technique, similar to what we did for proving the uniform distribution result.</p>
<p>More specifically, we divide the interval <span class="math inline">\([0, 1]\)</span> into <span class="math inline">\(N\)</span> consecutive segments. For each <span class="math inline">\(i \in \{1, 2, \ldots, N\}\)</span>, define segment <span class="math inline">\(i\)</span> as: <span class="math display">\[
S_i = \left[\sum_{j=1}^{i-1} \pi(x_j), \sum_{j=1}^{i} \pi(x_j)\right)
\]</span> where by convention, <span class="math inline">\(\sum_{j=1}^{0} \pi(x_j) = 0\)</span>.</p>
<p>Observe that segment <span class="math inline">\(S_i\)</span> has length: <span class="math display">\[
\text{length}(S_i) = \sum_{j=1}^{i} \pi(x_j) - \sum_{j=1}^{i-1} \pi(x_j) = \pi(x_i)
\]</span></p>
<p>Moreover, these segments partition <span class="math inline">\([0, 1]\)</span> since they are disjoint and: <span class="math display">\[
\bigcup_{i=1}^{N} S_i = [0, 1)
\]</span> which follows from the fact that <span class="math inline">\(\sum_{i=1}^{N} \pi(x_i) = 1\)</span> (since <span class="math inline">\(\pi\)</span> is a probability distribution). When we sample uniformly from <span class="math inline">\([0, 1]\)</span>, the probability of landing in segment <span class="math inline">\(i\)</span> is exactly <span class="math inline">\(\pi(x_i)\)</span> (since the segment has length <span class="math inline">\(\pi(x_i)).\)</span> So if we return <span class="math inline">\(x_i\)</span> whenever we land in segment <span class="math inline">\(i\)</span>, we get the desired distribution!</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Tip</span>Intuition
</div>
</div>
<div class="callout-body-container callout-body">
<p>Think of it like a dartboard: if you throw a dart uniformly at random on <span class="math inline">\([0,1]\)</span>, the probability of hitting a region is proportional to its length. By making segment <span class="math inline">\(i\)</span> have length <span class="math inline">\(\pi(x_i)\)</span>, we ensure the probability of hitting it matches our target probability.</p>
</div>
</div>
<p><em>Example:</em> Suppose <span class="math inline">\(\mathcal{X} = \{x_1, x_2, x_3, x_4, x_5\}\)</span> and <span class="math inline">\(\pi = (0.15, 0.25, 0.20, 0.30, 0.10)\)</span>. We segment the <span class="math inline">\([0, 1]\)</span> interval as shown below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="segmented_numberline.png" class="img-fluid figure-img" style="width:50.0%"></p>
<figcaption>Segmented [0, 1] Interval</figcaption>
</figure>
</div>
<p>Now, we can sample a real number uniformly random, and return the segment that this number belongs to.</p>
<section id="formalizing-the-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="formalizing-the-algorithm">Formalizing the Algorithm</h4>
<p>To implement this efficiently, we use cumulative probabilities. Define: <span class="math display">\[
F_i = \sum_{j=1}^{i} \pi(x_j) \quad \text{for } i = 1, 2, \ldots, N
\]</span> with <span class="math inline">\(F_0 = 0\)</span>. Note that <span class="math inline">\(F_i\)</span> represents the cumulative probability up to and including <span class="math inline">\(x_i\)</span>, so segment <span class="math inline">\(i\)</span> corresponds to the interval <span class="math inline">\([F_{i-1}, F_i)\)</span>.</p>
<p>Our algorithm returns <span class="math inline">\(x_i\)</span> when <span class="math inline">\(U\)</span> falls in the interval <span class="math inline">\([F_{i-1}, F_i)\)</span>:</p>
<div class="algorithm">
<p><strong>Algorithm 4</strong></p>
<p><strong>Preprocessing:</strong></p>
<p>Compute cumulative probabilities: <span class="math inline">\(F_0 \gets 0\)</span></p>
<p>for <span class="math inline">\(i = 1\)</span> to <span class="math inline">\(N\)</span> do</p>
<p><span class="math inline">\(\quad\)</span> <span class="math inline">\(F_i \gets F_{i-1} + \pi(x_i)\)</span></p>
<p><strong>Sampling:</strong></p>
<p>Generate <span class="math inline">\(U \sim \text{Uniform}[0, 1]\)</span> using Algorithm 3</p>
<p>for <span class="math inline">\(i = 1\)</span> to <span class="math inline">\(N\)</span> do</p>
<p><span class="math inline">\(\quad\)</span> if <span class="math inline">\(F_{i-1} \leq U &lt; F_i\)</span> then</p>
<p><span class="math inline">\(\quad\quad\)</span> return <span class="math inline">\(x_i\)</span></p>
</div>
<p>Let’s verify that this algorithm produces the correct distribution. For any <span class="math inline">\(x_i \in \mathcal{X}\)</span>:</p>
<p><span class="math display">\[\begin{align*}
\mathbb{P}[\text{output} = x_i] &amp;= \mathbb{P}[F_{i-1} \leq U &lt; F_i] \\
&amp;= F_i - F_{i-1} \tag{$U$ is uniform on $[0,1]$} \\
&amp;= \left(\sum_{j=1}^{i} \pi(x_j)\right) - \left(\sum_{j=1}^{i-1} \pi(x_j)\right) \\
&amp;= \pi(x_i)
\end{align*}\]</span></p>
<p>The second equality uses the fact that for a uniform random variable <span class="math inline">\(U\)</span> on <span class="math inline">\([0,1]\)</span>, we have <span class="math inline">\(\mathbb{P}[a \leq U &lt; b] = b - a\)</span>. Therefore, our algorithm produces samples distributed according to <span class="math inline">\(\pi\)</span>. Problem solved!</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="screen-reader-only">Note</span>Computational Complexity
</div>
</div>
<div class="callout-body-container callout-body">
<p>The preprocessing step takes <span class="math inline">\(O(N)\)</span> time to compute cumulative probabilities. Each sample then requires <span class="math inline">\(O(N)\)</span> time in the worst case to find which segment <span class="math inline">\(U\)</span> falls into (via linear search). This can be improved to <span class="math inline">\(O(\log N)\)</span> per sample using binary search, since the cumulative probabilities <span class="math inline">\(F_i\)</span> are sorted.</p>
</div>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/csuraparaju\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>